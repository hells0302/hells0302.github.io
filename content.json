[{"title":"四天做一个Android小说更新提醒APP#i·Novel#","date":"2017-04-03T14:53:42.000Z","path":"2017/04/03/iNovel/","text":"你是否喜欢看网络小说？是否一遍遍的去刷新网页查看小说是否更新？你是否迫切的想要一款app自动获取小说的更新情况并发出通知提醒？ 三天假期就快结束了，首先祝大家玩得开心。 前言自己有看小说的习惯，但是有时小说是否更新需要一遍遍的去刷新网页，耗时费神。最近一段时间忙于找实习面试看Android的一些知识。萌生了做一个提醒小说更新的app，顺便把最近看到学到的知识用上，既能方便自己又能巩固所学。 项目地址：https://github.com/hells0302/i-Nonel 效果图如下所示： 功能需求因为自己一直看小说，获取更新的问题之前也想过。 正确获取小说更新情况 能够同时显示多个小说的更新情况 可以保存小说列表以后自动获取 后台根据设置的时间间隔自动刷新并发出通知 夜间模式 通知栏、震动、呼吸灯提醒 以上几个需求主要涉及了UI，网络，数据存储，后台服务，传感器使用等 可行性分析首要的问题是怎么获取小数更新数据。这里使用了开源框架Jsoup。Jsoup官网摘抄官网简介介绍一下 jsoup is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jquery-like methods.jsoup implements the WHATWG HTML5 specification, and parses HTML to the same DOM as modern browsers do. scrape and parse HTML from a URL, file, or string find and extract data, using DOM traversal or CSS selectors manipulate the HTML elements, attributes, and text clean user-submitted content against a safe white-list, to prevent XSS attacks output tidy HTMLjsoup is designed to deal with all varieties of HTML found in the wild; from pristine and validating, to invalid tag-soup; jsoup will create a sensible parse tree. 通过Jsoup获取整个网页的数据，完后分析得到自己想要的数据。现阶段只做了一个小说网站的解析工作 #UI实验室没有做UI涉及的，参考做前端的大神给的建议，自己完成UI。期间也使用PS修图获取颜色代码等。推荐大家一个网站，上面的图标做的非常好。 Material iconshttps://material.io/icons/ #整体分析整个项目结构是按照功能进行分包的，这样以后修改的时候方便查找。工程监理号后，需要导入一下第三方开源库，如下图所示12345678910dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:25.1.1&apos; compile &apos;com.android.support:preference-v14:25.1.1&apos; compile &apos;com.android.support:design:25.1.1&apos; compile &apos;com.android.support:cardview-v7:25.1.1&apos; compile files(&apos;libs/jsoup-1.10.2.jar&apos;) compile files(&apos;libs/picasso-2.5.2.jar&apos;)&#125; 之前选择网络框架的时候，打算先使用Android-async-http，volley，OkHttp中的一个先把网页获取下来，然后再利用Jsoup解析，在上班之余，做的这个app，投了个懒直接使用了Jsoup获取网页。 首先先把网页请求，数据获取的工具类写完。常量类Constant，数据获取类HtmlParserUtil，和网络状态检测类NetworkState类 bean下的实体类Book和CacheBook，分别保存获取到的小说的一些信息，如小说名，作者，简介，图片Url，更新时间等 Application的实现，用来获取全局context以及后面的夜间模式 小说更新情况显示，小说添加，删除用到的ListView以及相应的adapter的实现 后台服务，以及后台服务中的Notification，以及才重新启动service用的BroadcastReceiver 刷新间隔使用了Android的Alarm机制 设置界面则是使用了Activity+PreferenceFragment的模式这里需要重点说明一下的是，数据库创建时使用了单例模式,关于单例模式的使用以及原理以后再详细阐述，这里不再过多描述。12345678910111213private DatabaseUtil(Context context) &#123; DatabaseHelper dbHelper=new DatabaseHelper(context,DB_NAME,null,VERSION); db=dbHelper.getWritableDatabase(); &#125; public synchronized static DatabaseUtil getInstance(Context context) &#123; if(databaseUtil==null) &#123; databaseUtil=new DatabaseUtil(context); &#125; return databaseUtil; &#125; #界面编写主页显示小说更新详情主要分为有图模式和无图模式主要说一下几个比较特殊的控件，其他具体请到GitHub下载代码。MainActivity中主要使用了DrawerLayout，SwipeRefreshLayout，Toolbar，NavigationView等实现导航栏，下拉刷新，侧滑导航等功能对应的布局如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:openDrawer=&quot;start&quot;&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/main&quot; &gt; &lt;ProgressBar android:layout_marginTop=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:id=&quot;@+id/pb&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; /&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;RelativeLayout android:id=&quot;@+id/titleBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; &gt; &lt;android.support.v7.widget.Toolbar android:gravity=&quot;center_vertical&quot; android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot; app:title=&quot; I·Novel&quot; android:minHeight=&quot;40dp&quot;&gt; &lt;ImageView android:onClick=&quot;update&quot; android:paddingRight=&quot;5dp&quot; android:layout_gravity=&quot;right&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/ic_autorenew_white_24dp&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/RelativeLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; android:id=&quot;@+id/refreshLayout&quot;&gt; &lt;ListView android:id=&quot;@+id/listView&quot; android:dividerHeight=&quot;8dp&quot; android:divider=&quot;@null&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/nav_header&quot; app:menu=&quot;@menu/drawer&quot; android:fitsSystemWindows=&quot;true&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; ListView中显示小说更新的布局，这里用了CardView更美观一些123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_height=&quot;96dp&quot; android:layout_width=&quot;match_parent&quot; android:focusable=&quot;true&quot; android:clickable=&quot;true&quot; android:foreground=&quot;?android:attr/selectableItemBackground&quot; app:cardCornerRadius=&quot;4dp&quot; app:cardElevation=&quot;1dp&quot; app:cardPreventCornerOverlap=&quot;true&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot;&gt; &lt;LinearLayout android:paddingLeft=&quot;8dp&quot; android:paddingRight=&quot;8dp&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:layout_marginTop=&quot;8dp&quot; android:layout_marginBottom=&quot;8dp&quot; android:id=&quot;@+id/book_img&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;100dp&quot; android:src=&quot;@drawable/bookimg&quot;/&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_marginTop=&quot;8dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:id=&quot;@+id/book_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;16sp&quot; android:textStyle=&quot;bold&quot; android:text=&quot;圣墟&quot;/&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:id=&quot;@+id/author&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;辰东&quot;/&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;著&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:id=&quot;@+id/info&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;在破败中崛起，在寂灭中复苏。沧海成尘，雷电枯竭……&quot;/&gt; &lt;LinearLayout android:paddingLeft=&quot;10dp&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;最近更新：&quot;/&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:id=&quot;@+id/update_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;第三百零六章 难解&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:paddingLeft=&quot;10dp&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;更新时间：&quot;/&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:id=&quot;@+id/update_time&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;今天18:16更新&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 设置界面使用了PreferenceFragment对应的布局和Preference的xml如下用FrameLayout来放置碎片布局12345678910111213141516171819202122&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;android.support.v7.widget.Toolbar android:gravity=&quot;center_vertical&quot; android:id=&quot;@+id/setting_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot; app:title=&quot; 设置&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;FrameLayout android:id=&quot;@+id/frameLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 设置的想用参数用PreferenceScreen设置，提供了SharedPreferences存储，无需手动设置123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;PreferenceCategory android:title=&quot;基本设置&quot;&gt; &lt;CheckBoxPreference android:title=&quot;无图模式&quot; android:key=&quot;no_picture_mode&quot; android:defaultValue=&quot;false&quot; android:summary=&quot;首页不显示小说图片&quot; /&gt; &lt;ListPreference android:title=&quot;刷新时间&quot; android:key=&quot;time_of_refresh&quot; android:entries=&quot;@array/time_to_refresh_pots&quot; android:dialogTitle=&quot;请选择刷新时间&quot; android:entryValues=&quot;@array/time_to_refresh&quot; android:defaultValue=&quot;6&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;通知提醒设置&quot;&gt; &lt;CheckBoxPreference android:title=&quot;震动&quot; android:key=&quot;vibrator_mode&quot; android:defaultValue=&quot;false&quot; android:summary=&quot;设置是否震动提醒&quot; /&gt; &lt;CheckBoxPreference android:title=&quot;呼吸灯&quot; android:key=&quot;light_mode&quot; android:defaultValue=&quot;false&quot; android:summary=&quot;设置呼吸灯闪烁提醒&quot; /&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; 其他布局大体相似，具体请到GitHub下载源码 #刷新数据&amp;&amp;本地化数据在小说添加界面所添加的小说绘存到相应的数据库表里实现数据本地化为了节省流量以及刷新的时间，把获取小说链接地址的网络请求和获取小说更新详情的网络请求分别开来。获取小说更新详情的网络请求很频繁，而获取小说链接地址在添加小说或者删除小说时才需要获取。1234567891011121314151617181920212223242526272829303132333435363738394041/** * 根据添加的小说获取小说详情链接地址 */public void updateNovelInfoLink()&#123; //如果添加的小说数量为0，则表示已删除所有小说，清空数据库缓存 if(databaseUtil.getNovelLinkCount()==0) &#123; databaseUtil.delNovelInfoLinkElement(); refresh(); &#125; //当添加的小说总数和获取到的小说链接总数不同，说明再次添加小说或者删除小说，刷新 if(databaseUtil.getNovelInfoLinkCount()!=databaseUtil.getNovelLinkCount()) &#123; databaseUtil.delNovelInfoLinkElement(); if(NetworkState.networkConnected(MainActivity.this)&amp;&amp;(NetworkState.wifiConnected(MainActivity.this)||NetworkState.mobileDataConnected(MainActivity.this))) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Map&lt;String,String&gt; map; Iterator iterator; List&lt;Map&lt;String,String&gt;&gt; listLinks=databaseUtil.getNovelLinkElement(); for(int i=0;i&lt;listLinks.size();i++)&#123; map=listLinks.get(i); iterator=map.keySet().iterator(); String name=(String)iterator.next(); String tmpUrl1=map.get(name); String tmpUrl2=HtmlParserUtil.getNovelLink(tmpUrl1); databaseUtil.addLinkToNovelInfoLink(name,&quot;http:&quot;+tmpUrl2); &#125; refresh(); &#125; &#125;).start(); &#125; &#125;else &#123; refresh(); &#125;&#125; 获取小说更新详情12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 刷新更新内容 */ public void refresh() &#123; //更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; swipeRefreshLayout.setRefreshing(true); &#125; &#125;); //获取数据库中小说链接总数 int count=databaseUtil.getNovelInfoLinkCount(); //更新时防止listview重复显示 if(list.size()&gt;0) &#123; list.clear(); &#125; //数据库中小说链接总数为0，说明未添加小说 if(count==0) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; swipeRefreshLayout.setRefreshing(false); adapter.notifyDataSetChanged(); &#125; &#125;); Toast.makeText(MainActivity.this,&quot;还未添加小说，请先添加小说&quot;,Toast.LENGTH_SHORT).show(); &#125;else &#123; //有网络是更新 if(NetworkState.networkConnected(MainActivity.this)&amp;&amp;(NetworkState.wifiConnected(MainActivity.this)||NetworkState.mobileDataConnected(MainActivity.this))) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; if(list.size()&gt;0) &#123; list.clear(); &#125; //获取小说链接地址 List&lt;String&gt; list12= databaseUtil.getNovelInfoLinkElement(); for(int i=0;i&lt;list12.size();i++) &#123; Book book=HtmlParserUtil.getUpdateInfo(list12.get(i)); list.add(book); &#125; handler.sendEmptyMessage(0x123); &#125; &#125;).start(); &#125;else &#123; Toast.makeText(MainActivity.this,&quot;无网络连接，请检查...&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; #显示数据因为使用里ListView显示，所以首先需要一个adapter，在adapter中根据设置页面是否是无图模式，选择是否加载图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Created by dnw on 2017/3/31. */public class UpdateAdapter extends BaseAdapter&#123; public Context context; public List&lt;Book&gt; bookUpdateList; SharedPreferences sharedPreferences; public UpdateAdapter(Context context, List&lt;Book&gt; list) &#123; this.context=context; this.bookUpdateList=list; &#125; @Override public int getCount() &#123; return bookUpdateList.size(); &#125; @Override public Object getItem(int position) &#123; return bookUpdateList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; sharedPreferences=PreferenceManager.getDefaultSharedPreferences(context); Book book=(Book) getItem(position); ViewHolder holder; View view; UpdateAdapter.this.notifyDataSetChanged(); if(convertView==null) &#123; view=LayoutInflater.from(context).inflate(R.layout.book_item,null); holder=new ViewHolder(); holder.book_name=(TextView)view.findViewById(R.id.book_name); holder.author=(TextView)view.findViewById(R.id.author); holder.info=(TextView)view.findViewById(R.id.info); holder.update_title=(TextView)view.findViewById(R.id.update_title); holder.update_time=(TextView)view.findViewById(R.id.update_time); holder.book_img=(ImageView)view.findViewById(R.id.book_img); view.setTag(holder); &#125;else &#123; view=convertView; holder=(ViewHolder) view.getTag(); &#125; if(!sharedPreferences.getBoolean(&quot;no_picture_mode&quot;,true)) &#123; holder.book_img.setVisibility(View.VISIBLE); Picasso.with(context).load(&quot;https:&quot;+book.imgUrl).into(holder.book_img); &#125;else &#123; holder.book_img.setVisibility(View.GONE); &#125; holder.book_name.setText(book.bookName); holder.author.setText(book.author); holder.info.setText(book.info); holder.update_title.setText(book.updateTitle); holder.update_time.setText(book.updateTime); return view; &#125; class ViewHolder &#123; private TextView book_name; private TextView author; private TextView info; private TextView update_title; private TextView update_time; private ImageView book_img; &#125;&#125; #缓存数据缓存数据用的是数据库，主要有两个类DatabaseHelper用于创建个更新数据库，DatabaseUtil类主要是一些操作数据库的函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DatabaseHelper extends SQLiteOpenHelper &#123; public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; @Override public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; //添加小说表创建语句 sqLiteDatabase.execSQL(&quot;create table if not exists novel_link(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;url text)&quot;); //小说详情链接表 sqLiteDatabase.execSQL(&quot;create table if not exists novel_info_link(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;url text)&quot;); //小说更新缓存表 sqLiteDatabase.execSQL(&quot;create table if not exists novel_cache(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;author text,&quot; + &quot;updateTitle text,&quot; + &quot;updateTime text)&quot;); &#125; @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123; switch(i) &#123; case 1: sqLiteDatabase.execSQL(&quot;create table if not exists novel_info_link(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;url text)&quot;); sqLiteDatabase.execSQL(&quot;create table if not exists novel_cache(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;author text,&quot; + &quot;updateTitle text,&quot; + &quot;updateTime text)&quot;); case 2: sqLiteDatabase.execSQL(&quot;create table if not exists novel_cache(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;author text,&quot; + &quot;updateTitle text,&quot; + &quot;updateTime text)&quot;); default: &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236/** * Created by dnw on 2017/4/1. */public class DatabaseUtil &#123; public static final String DB_NAME=&quot;novel.db&quot;; public static final int VERSION=1; private SQLiteDatabase db; private static DatabaseUtil databaseUtil; private DatabaseUtil(Context context) &#123; DatabaseHelper dbHelper=new DatabaseHelper(context,DB_NAME,null,VERSION); db=dbHelper.getWritableDatabase(); &#125; public synchronized static DatabaseUtil getInstance(Context context) &#123; if(databaseUtil==null) &#123; databaseUtil=new DatabaseUtil(context); &#125; return databaseUtil; &#125; /** * 添加想要跟踪的小说到数据库 * @param novelName * @param url * @return */ public boolean addLinkToDatabase(String novelName,String url) &#123; ContentValues values=new ContentValues(); values.put(&quot;novel_name&quot;,novelName); values.put(&quot;url&quot;,url); db.insert(&quot;novel_link&quot;,null,values); return true; &#125; /** * 获取到的小说详情链接存储到数据库 * @param novelName * @param url * @return */ public boolean addLinkToNovelInfoLink(String novelName,String url) &#123; ContentValues values=new ContentValues(); values.put(&quot;novel_name&quot;,novelName); values.put(&quot;url&quot;,url); db.insert(&quot;novel_info_link&quot;,null,values); return true; &#125; /** * 缓存到数据库 * @param novelName * @param author * @param update * @param time * @return */ public boolean cacheToNovelCache(String novelName,String author,String update,String time) &#123; ContentValues values=new ContentValues(); values.put(&quot;novel_name&quot;,novelName); values.put(&quot;author&quot;,author); values.put(&quot;updateTitle&quot;,update); values.put(&quot;updateTime&quot;,time); db.insert(&quot;novel_cache&quot;,null,values); return true; &#125; /** * 获取所添加的小说数量 * @return */ public int getNovelLinkCount() &#123; String sql=&quot;select count(*) from novel_link&quot;; Cursor cursor=db.rawQuery(sql,null); cursor.moveToFirst(); int count=(int)cursor.getLong(0); cursor.close(); return count; &#125; /** * 取小说详情链接的数量 * @return */ public int getNovelInfoLinkCount() &#123; String sql=&quot;select count(*) from novel_info_link&quot;; Cursor cursor=db.rawQuery(sql,null); cursor.moveToFirst(); int count=(int)cursor.getLong(0); cursor.close(); return count; &#125; /** * 获取添加的小说list * @return */ public List&lt;Map&lt;String,String&gt;&gt; getNovelLinkElement() &#123; List&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&lt;&gt;(); Map&lt;String,String&gt; map; Cursor cursor=db.query(&quot;novel_link&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; map=new HashMap&lt;&gt;(); String url=cursor.getString(cursor.getColumnIndex(&quot;url&quot;)); String name=cursor.getString(cursor.getColumnIndex(&quot;novel_name&quot;)); map.put(name,url); list.add(map); &#125;while(cursor.moveToNext()); &#125; cursor.close(); return list; &#125; /** * 获取获取的小说详情链接list * @return */ public List&lt;String&gt; getNovelInfoLinkElement() &#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); Cursor cursor=db.query(&quot;novel_info_link&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; String url=cursor.getString(cursor.getColumnIndex(&quot;url&quot;)); list.add(url); &#125;while(cursor.moveToNext()); &#125; cursor.close(); return list; &#125; /** * 获取添加的小说链接 * @return */ public List&lt;String&gt; getNovelNameElement() &#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); Cursor cursor=db.query(&quot;novel_link&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; String url=cursor.getString(cursor.getColumnIndex(&quot;novel_name&quot;)); list.add(url); &#125;while(cursor.moveToNext()); &#125; return list; &#125; public List&lt;CacheBook&gt; getNovelCacheElement() &#123; List&lt;CacheBook&gt; list=new ArrayList&lt;&gt;(); Cursor cursor=db.query(&quot;novel_cache&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; CacheBook book=new CacheBook(); book.cacheBookName=cursor.getString(cursor.getColumnIndex(&quot;novel_name&quot;)); book.cacheAuthor=cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); book.cacheUpdateTitle=cursor.getString(cursor.getColumnIndex(&quot;updateTitle&quot;)); book.cacheUpdateTime=cursor.getString(cursor.getColumnIndex(&quot;updateTime&quot;)); list.add(book); &#125;while(cursor.moveToNext()); &#125; return list; &#125; /** * 删除数据库中添加的小说 * @param novelName * @return */ public boolean delNovelLinkElement(String novelName) &#123; int deleteRow=db.delete(&quot;novel_link&quot;,&quot;novel_name=?&quot;,new String[]&#123;novelName&#125;); if(deleteRow&gt;=0) return true; return false; &#125; /** * 删除cache数据库链接 * @return */ public boolean delAllNovelCacheElement() &#123; db.delete(&quot;novel_cache&quot;,null,null); return true; &#125; public boolean delNovelInfoLinkElement() &#123; db.delete(&quot;novel_info_link&quot;,null,null); return true; &#125; /** * 判断小说是否存在 * @param novelName * @return */ public boolean isExist(String novelName) &#123; Cursor cursor=db.query(&quot;novel_link&quot;,null,&quot;novel_name=?&quot;,new String[]&#123;novelName&#125;,null,null,null); if(cursor.moveToFirst()) &#123; return true; &#125; cursor.close(); return false; &#125; /** * 判断小说链接是否存在 * @param novelName * @return */ public boolean isNovelInfoExist(String novelName) &#123; Cursor cursor=db.query(&quot;novel_info_link&quot;,null,&quot;novel_name=?&quot;,new String[]&#123;novelName&#125;,null,null,null); if(cursor.moveToFirst()) &#123; return true; &#125; cursor.close(); return false; &#125;&#125; #后台更新后台更新主要使用了service以及Android的Alarm机制实现定时任务，以及Notification实现通知,然后使用了BoradReceiver在刷新时间到了的时候重新开启服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * Created by dnw on 2017/4/3. */public class CacheService extends Service &#123; public static final int anHour=60*60*1000; private List&lt;CacheBook&gt; lastList; private DatabaseUtil databaseUtil=DatabaseUtil.getInstance(this); private NotificationManager nm; private int setHour; SharedPreferences sharedPreferences; Handler handler=new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if(msg.what==0x234) &#123; //此处比较两个列表是否相同 List&lt;CacheBook&gt; listDb=databaseUtil.getNovelCacheElement(); //循环比较 if(lastList.size()&gt;0&amp;&amp;listDb.size()&gt;0) &#123; for(int i=0;i&lt;lastList.size();i++) &#123; CacheBook book1=lastList.get(i); for(int j=0;j&lt;listDb.size();j++) &#123; CacheBook book2=listDb.get(j); //书名相同之后比较两书的更新时间，不同发出更新通知 if(book1.cacheBookName.equals(book2.cacheBookName)) &#123; if(!book1.cacheUpdateTime.equals(book2.cacheUpdateTime)) &#123; //此处发出更新通知 Intent intent=new Intent(CacheService.this, MainActivity.class); PendingIntent pi=PendingIntent.getActivity(CacheService.this,0,intent,0); Notification.Builder builder=new Notification.Builder(CacheService.this); builder.setContentTitle(book2.cacheBookName+&quot;&gt;&gt;有更新&quot;); builder.setContentText(book2.cacheUpdateTitle+&quot; &quot;+book2.cacheUpdateTime); builder.setWhen(System.currentTimeMillis()); builder.setSmallIcon(R.drawable.notication_icon); builder.setContentIntent(pi); //获取设置页的是否震动参数 if(sharedPreferences.getBoolean(&quot;vibrator_mode&quot;,false)) &#123; builder.setDefaults(Notification.DEFAULT_VIBRATE); &#125; //获取设置页的呼吸灯是否闪烁参数 if(sharedPreferences.getBoolean(&quot;light_mode&quot;,false)) &#123; builder.setDefaults(Notification.DEFAULT_LIGHTS); &#125; Notification notification=builder.getNotification(); //注意每一条更新都要通知 nm.notify(j,notification); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); nm=(NotificationManager)getSystemService(NOTIFICATION_SERVICE); sharedPreferences= PreferenceManager.getDefaultSharedPreferences(this); &#125; @Override public boolean onUnbind(Intent intent) &#123; return super.onUnbind(intent); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if(sharedPreferences==null) sharedPreferences= PreferenceManager.getDefaultSharedPreferences(this); if(nm==null) nm=(NotificationManager)getSystemService(NOTIFICATION_SERVICE); setHour=Integer.parseInt(sharedPreferences.getString(&quot;time_of_refresh&quot;,&quot;1&quot;)); //时间间隔到后执行 new Thread(new Runnable() &#123; @Override public void run() &#123; cacheRefresh(); handler.sendEmptyMessage(0x234); &#125; &#125;).start(); AlarmManager manager=(AlarmManager)getSystemService(ALARM_SERVICE); long triggerAtTime= SystemClock.elapsedRealtime()+setHour*anHour; Intent i=new Intent(this,AlarmReceiver.class); PendingIntent pi=PendingIntent.getBroadcast(this,0,i,0); int currentVersion=Build.VERSION.SDK_INT; if(currentVersion&gt;=19) &#123; manager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); &#125;else &#123; manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); &#125; return super.onStartCommand(intent, flags, startId); &#125; private void cacheRefresh() &#123; //更新之前获取上次更新的数据 lastList=databaseUtil.getNovelCacheElement(); if(databaseUtil.getNovelInfoLinkCount()&gt;0) &#123; if(NetworkState.networkConnected(this)&amp;&amp;(NetworkState.wifiConnected(this)||NetworkState.mobileDataConnected(this))) &#123; List&lt;String&gt;listLink=databaseUtil.getNovelInfoLinkElement(); if(databaseUtil.delAllNovelCacheElement()) for(int i=0;i&lt;listLink.size();i++) &#123; CacheBook book=HtmlParserUtil.getCacheUpdateInfo(listLink.get(i)); if(book!=null) databaseUtil.cacheToNovelCache(book.cacheBookName,book.cacheAuthor,book.cacheUpdateTitle,book.cacheUpdateTime); &#125; &#125; &#125; &#125;&#125; 可以看到在BoradReceiver中只做了一件事，就是重新启动service，这样就可以不断以设置的刷新时间来运行后台服务12345678public class AlarmReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //时间到后再次启动service Intent i=new Intent(context, CacheService.class); context.startService(i); &#125;&#125; #夜间模式日间模式与夜间模式就是给APP定义并应用两套不同颜色的主题由于Support Library在23.2.0的版本中才添加了Theme.AppCompat.DayNight主题，所以依赖的版本必须是高于23.2.0的，并且，这个特性支持的最低SDK版本为14，所以，需要兼容Android 4.0的设备，是不能使用这个特性的，在API Level 14以下的设备会默认使用亮色主题。具体不在阐述，网上有很多实现教程。 #版本适配主要有两类： Android 版本配置 屏幕适配 为不同屏幕尺寸和不同可绘制对象提供不同的布局设计 #其他恩，未经版权所有方如小说网站许可，有点侵权了。所以，本app只用于学习研究，不用于商业 谢谢您的阅读~~~","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"Java顺序存储实现线性表","date":"2017-03-28T08:21:51.000Z","path":"2017/03/28/array-list/","text":"顺序存储实现线性表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class test &#123; //线性表的长度 private static final int MAXSIZE=20; //线性表数据 int getData=0; //线性表长度 int length=0; public static void main(String args[]) &#123; int arr[]=new int[MAXSIZE]; test test1=new test(); for(int i=0;i&lt;4;i++) &#123; arr[i]=i+1; test1.length++; &#125; test1.insert(arr, 3, 5); if(test1.get(arr, 3)) &#123; System.out.println(test1.getData+&quot;&quot;); &#125; test1.delete(arr, 3); if(test1.get(arr, 3)) &#123; System.out.println(test1.getData+&quot;&quot;); &#125; test1.get(arr, 2); &#125; public boolean get(int[] arr,int num) &#123; if(length==0||num&lt;1||num&gt;length+1) return false; getData=arr[num-1]; return true; &#125; public boolean insert(int[] arr,int num,int elem) &#123; int i=0; if(num&lt;1||num&gt;length+1) return false; //如果线性表已满 if(length==arr.length) return false; //如果不是表尾，将要插入位置后的数据后移一位 if(num&lt;=length) &#123; for(i=length-1;i&gt;=num-1;i--) &#123; arr[i+1]=arr[i]; &#125; &#125; arr[num-1]=elem; length++; return true; &#125; public boolean delete(int []arr,int num) &#123; if(length==0||num&lt;1||num&gt;length+1) &#123; return false; &#125; getData=arr[num-1]; if(num&lt;length) &#123; for(int k=num;k&lt;length;k++) &#123; arr[k-1]=arr[k]; &#125; &#125; length--; return true; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Java实现链式存储线性表","date":"2017-03-28T08:21:42.000Z","path":"2017/03/28/linked-list/","text":"实现链式存储线性表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Test &#123; int getData=0; public static void main(String[] args) &#123; // TODO Auto-generated method stub //初始化链表 Node node1=new Node(); node1.data=1; Node node2=new Node(); node1.next=node2; node2.data=2; node2.next=null; //定义一个头指针指向第一个节点 Node p=new Node(); p.next=node1; Test test=new Test(); if(test.get(p, 1)) System.out.println(test.getData); test.insert(p, 2, 3); while(p!=null) &#123; System.out.print(&quot; &quot;+p.data); p=p.next; &#125; &#125; public boolean get(Node node,int num) &#123; int i=1; Node pNode; pNode=node.next; while(pNode!=null&amp;&amp;i&lt;num) &#123; pNode=pNode.next; i++; &#125; if(pNode==null||i&gt;num) return false; getData=pNode.data; return true; &#125; public boolean insert(Node node,int num,int item) &#123; int i=1; Node pNode=node.next; while(pNode!=null&amp;&amp;i&lt;num) &#123; pNode=pNode.next; i++; &#125; if(pNode==null||i&gt;num) &#123; return false; &#125; Node sNode=new Node(); sNode.data=item; sNode.next=pNode.next; pNode.next=sNode; return true; &#125; public boolean delete(Node node,int num) &#123; int i=1; Node pNode=node.next; while(pNode!=null&amp;&amp;i&lt;num) &#123; pNode=pNode.next; i++; &#125; if(pNode==null||i&gt;num) &#123; return false; &#125; Node sNode=pNode.next; pNode.next=sNode.next; return true; &#125;&#125;class Node&#123; int data; Node next;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"KMP匹配模式算法","date":"2017-03-28T08:06:22.000Z","path":"2017/03/28/KMP/","text":"KMP匹配模式算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class KMP &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] next=new int[10]; get_nextval(&quot;fgh&quot;, next); System.out.println(kmp(&quot;abcdefghijklmn&quot;, &quot;fgh&quot;, next)); &#125; public static int kmp(String str,String substr,int []next) &#123; int i=0; int j=0; while(i&lt;str.length()&amp;&amp;j&lt;substr.length()) &#123; if(str.charAt(i)==substr.charAt(j)) &#123; ++i; ++j; &#125; else &#123; j=next[j]; if(j==-1) &#123; j=0; ++i; &#125; &#125; &#125; if(j==substr.length()) return i-substr.length(); else return -1; &#125; public static void get_next(String substr,int[] next) &#123; int i=0; int j=-1; next[0]=-1; while(i&lt;substr.length()) &#123; if(j==-1||substr.charAt(i)==substr.charAt(j)) &#123; ++i; ++j; next[i]=j; &#125; else&#123; j=next[j]; &#125; &#125; &#125; //改进，当字符重复时，进一步减少多余判断 public static void get_nextval(String substr,int[] next) &#123; int i=0; int j=-1; next[0]=-1; while(i&lt;substr.length()) &#123; if(j==-1||substr.charAt(i)==substr.charAt(j)) &#123; ++i; ++j; //next[i]=j; if(i&lt;substr.length()&amp;&amp;j&lt;substr.length()) &#123; if(substr.charAt(i)!=substr.charAt(j)) next[i]=j; else next[i]=next[j]; &#125; &#125; else&#123; j=next[j]; &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"在Linux新建Git服务器","date":"2017-03-27T08:10:32.000Z","path":"2017/03/27/Create-a-git-server/","text":"这几天导师要求在实验室的服务器上(CentOS)搭建一个Git仓库用于管理实验室项目代码。正好在搭建个人博客，就把这个过程贴上来。CentOS的安装就不在多说。 安装git1yum install git 创建一个git用户用来运行git服务1useradd -m git 安装Gitosis管理公钥安装命令 1234yum install -y python python-setuptools git-coregit clone https://github.com/res0nat0r/gitosis.gitcd gitosispython setup.py install 软件安装完之后是一些配置。先用服务器生成的ssh公钥初始化gitosis。然后把远程PC的公钥添加进并添加管理权限，即可在远程pc管理项目12ssh-keygen -t rsa(一路回车即可)cp ~/.ssh/id_rsa.pub /tmp/ 用刚才的公钥初始化gitosis12su gitgitosis-init&lt;/tmp/id_rsa.pub 在/home/git文件夹下面会生成gitosis和repositories两个文件夹。repositories即为存放公共库的文件夹。 修改/home/git/repositories/gitosis-admin.git/hooks/post-update权限，使具有执行权限1chmod 775 /home/git/repositories/gitosis-admin.git/hooks/post-update 然后在git桌面上克隆gitosis-admin 然后把PC生成的公钥放到keydir文件夹中，在gitosis.conf中添加管理员权限就可以在PC上远程管理权限和git项目注意：此处公钥的文件名必须改成公钥文件里面最后的用户名，如下图所示的root@cnc217： PC具有权限之后，就可以在自己的电脑上管理git项目和权限，如需新添加开发成员，只需把新成员电脑生成的公钥放到gitosis-admin中keydir，在gitosis.conf中在相应的项目中添加新成员即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]