[{"title":"array list","date":"2017-03-28T08:21:51.000Z","path":"2017/03/28/array-list/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class test &#123; //线性表的长度 private static final int MAXSIZE=20; //线性表数据 int getData=0; //线性表长度 int length=0; public static void main(String args[]) &#123; int arr[]=new int[MAXSIZE]; test test1=new test(); for(int i=0;i&lt;4;i++) &#123; arr[i]=i+1; test1.length++; &#125; test1.insert(arr, 3, 5); if(test1.get(arr, 3)) &#123; System.out.println(test1.getData+&quot;&quot;); &#125; test1.delete(arr, 3); if(test1.get(arr, 3)) &#123; System.out.println(test1.getData+&quot;&quot;); &#125; test1.get(arr, 2); &#125; public boolean get(int[] arr,int num) &#123; if(length==0||num&lt;1||num&gt;length+1) return false; getData=arr[num-1]; return true; &#125; public boolean insert(int[] arr,int num,int elem) &#123; int i=0; if(num&lt;1||num&gt;length+1) return false; //如果线性表已满 if(length==arr.length) return false; //如果不是表尾，将要插入位置后的数据后移一位 if(num&lt;=length) &#123; for(i=length-1;i&gt;=num-1;i--) &#123; arr[i+1]=arr[i]; &#125; &#125; arr[num-1]=elem; length++; return true; &#125; public boolean delete(int []arr,int num) &#123; if(length==0||num&lt;1||num&gt;length+1) &#123; return false; &#125; getData=arr[num-1]; if(num&lt;length) &#123; for(int k=num;k&lt;length;k++) &#123; arr[k-1]=arr[k]; &#125; &#125; length--; return true; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"Java实现链式存储线性表","date":"2017-03-28T08:21:42.000Z","path":"2017/03/28/linked-list/","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Test &#123; int getData=0; public static void main(String[] args) &#123; // TODO Auto-generated method stub //初始化链表 Node node1=new Node(); node1.data=1; Node node2=new Node(); node1.next=node2; node2.data=2; node2.next=null; //定义一个头指针指向第一个节点 Node p=new Node(); p.next=node1; Test test=new Test(); if(test.get(p, 1)) System.out.println(test.getData); test.insert(p, 2, 3); while(p!=null) &#123; System.out.print(&quot; &quot;+p.data); p=p.next; &#125; &#125; public boolean get(Node node,int num) &#123; int i=1; Node pNode; pNode=node.next; while(pNode!=null&amp;&amp;i&lt;num) &#123; pNode=pNode.next; i++; &#125; if(pNode==null||i&gt;num) return false; getData=pNode.data; return true; &#125; public boolean insert(Node node,int num,int item) &#123; int i=1; Node pNode=node.next; while(pNode!=null&amp;&amp;i&lt;num) &#123; pNode=pNode.next; i++; &#125; if(pNode==null||i&gt;num) &#123; return false; &#125; Node sNode=new Node(); sNode.data=item; sNode.next=pNode.next; pNode.next=sNode; return true; &#125; public boolean delete(Node node,int num) &#123; int i=1; Node pNode=node.next; while(pNode!=null&amp;&amp;i&lt;num) &#123; pNode=pNode.next; i++; &#125; if(pNode==null||i&gt;num) &#123; return false; &#125; Node sNode=pNode.next; pNode.next=sNode.next; return true; &#125;&#125;class Node&#123; int data; Node next;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"KMP匹配模式算法","date":"2017-03-28T08:06:22.000Z","path":"2017/03/28/KMP/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class KMP &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] next=new int[10]; get_nextval(&quot;fgh&quot;, next); System.out.println(kmp(&quot;abcdefghijklmn&quot;, &quot;fgh&quot;, next)); &#125; public static int kmp(String str,String substr,int []next) &#123; int i=0; int j=0; while(i&lt;str.length()&amp;&amp;j&lt;substr.length()) &#123; if(str.charAt(i)==substr.charAt(j)) &#123; ++i; ++j; &#125; else &#123; j=next[j]; if(j==-1) &#123; j=0; ++i; &#125; &#125; &#125; if(j==substr.length()) return i-substr.length(); else return -1; &#125; public static void get_next(String substr,int[] next) &#123; int i=0; int j=-1; next[0]=-1; while(i&lt;substr.length()) &#123; if(j==-1||substr.charAt(i)==substr.charAt(j)) &#123; ++i; ++j; next[i]=j; &#125; else&#123; j=next[j]; &#125; &#125; &#125; //改进，当字符重复时，进一步减少多余判断 public static void get_nextval(String substr,int[] next) &#123; int i=0; int j=-1; next[0]=-1; while(i&lt;substr.length()) &#123; if(j==-1||substr.charAt(i)==substr.charAt(j)) &#123; ++i; ++j; //next[i]=j; if(i&lt;substr.length()&amp;&amp;j&lt;substr.length()) &#123; if(substr.charAt(i)!=substr.charAt(j)) next[i]=j; else next[i]=next[j]; &#125; &#125; else&#123; j=next[j]; &#125; &#125; &#125;&#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"在Linux新建Git服务器","date":"2017-03-27T08:10:32.000Z","path":"2017/03/27/Create-a-git-server/","text":"这几天导师要求在实验室的服务器上(CentOS)搭建一个Git仓库用于管理实验室项目代码。正好在搭建个人博客，就把这个过程贴上来。CentOS的安装就不在多说。 安装git1yum install git 创建一个git用户用来运行git服务1useradd -m git 安装Gitosis管理公钥安装命令 1234yum install -y python python-setuptools git-coregit clone https://github.com/res0nat0r/gitosis.gitcd gitosispython setup.py install 软件安装完之后是一些配置。先用服务器生成的ssh公钥初始化gitosis。然后把远程PC的公钥添加进并添加管理权限，即可在远程pc管理项目12ssh-keygen -t rsa(一路回车即可)cp ~/.ssh/id_rsa.pub /tmp/ 用刚才的公钥初始化gitosis12su gitgitosis-init&lt;/tmp/id_rsa.pub 在/home/git文件夹下面会生成gitosis和repositories两个文件夹。repositories即为存放公共库的文件夹。 修改/home/git/repositories/gitosis-admin.git/hooks/post-update权限，使具有执行权限1chmod 775 /home/git/repositories/gitosis-admin.git/hooks/post-update 然后在git桌面上克隆gitosis-admin 然后把PC生成的公钥放到keydir文件夹中，在gitosis.conf中添加管理员权限就可以在PC上远程管理权限和git项目注意：此处公钥的文件名必须改成公钥文件里面最后的用户名，如下图所示的root@cnc217： PC具有权限之后，就可以在自己的电脑上管理git项目和权限，如需新添加开发成员，只需把新成员电脑生成的公钥放到gitosis-admin中keydir，在gitosis.conf中在相应的项目中添加新成员即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]