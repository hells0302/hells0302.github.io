[{"title":"RemoteView实现跨进程更新UI解决不能使用setImageResource(int)","date":"2017-08-04T06:00:53.000Z","path":"2017/08/04/RemoteView/","text":"今天使用RemoteViews跨进程更新UI时报错，记录解决方案 错误提示1android.widget.RemoteViews$ActionException: view: android.support.v7.widget.AppCompatImageView can&apos;t use method with RemoteViews: setImageResource(int) 解决方法方案1所有的Activity都集成自Activity而非AppcompatActivity 方案二Activity继承自AppcompatActivity在build.gradle中设置appcompat为compile ‘com.android.support:appcompat-v7:23.0.1’或更低 原因android.support.v7.widget.AppCompatImageView在version23.1.0以取消相应的方法","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"使用AIDL通信的时候，Service绑定问题","date":"2017-07-19T08:30:00.000Z","path":"2017/07/19/AIDL-Service/","text":"解决使用AIDL通信的时候，Service绑定问题 如下启动远程Service时，会报错，因为Android5.0中service的intent一定要显性声明，当显示绑定的时候不会报错。123Intent intent=new Intent();intent.setAction(&quot;com.study.ipctest_aidl.BookManagerService&quot;);bindService(intent,connection,BIND_AUTO_CREATE); 解决方法一因为在两个不同的应用，必须隐式调用，可以通过函数把隐式应用编程显示调用123456789101112131415161718192021222324public static Intent createExplicitFromImplicitIntent(Context context, Intent implicitIntent) &#123; // Retrieve all services that can match the given intent PackageManager pm = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, 0); // Make sure only one match was found if (resolveInfo == null || resolveInfo.size() != 1) &#123; return null; &#125; // Get component info and create ComponentName ResolveInfo serviceInfo = resolveInfo.get(0); String packageName = serviceInfo.serviceInfo.packageName; String className = serviceInfo.serviceInfo.name; ComponentName component = new ComponentName(packageName, className); // Create a new intent. Use the old one for extras and such reuse Intent explicitIntent = new Intent(implicitIntent); // Set the component to be explicit explicitIntent.setComponent(component); return explicitIntent; &#125; 然后下面调用就可以解决1234final Intent intent=new Intent();intent.setAction(&quot;com.study.ipctest_aidl.BookManagerService&quot;);final Intent intent1=new Intent(createExplicitFromImplicitIntent(MainActivity.this,intent));bindService(intent1,connection,BIND_AUTO_CREATE); 解决方法二123Intent intent=new Intent(&quot;com.study.ipctest_aidl.BookManagerService&quot;);intent.setPackage(&quot;com.study.ipctest_aidl&quot;);bindService(intent,connection,BIND_AUTO_CREATE);","tags":[]},{"title":"遍历二叉树_前中后序","date":"2017-04-22T06:57:44.000Z","path":"2017/04/22/遍历二叉树-前中后序/","text":"二叉树前后中序遍历学习笔记 节点1234567891011121314private class Node&#123; // 左节点 private Node leftChild; // 右节点 private Node rightChild; // 节点对应的值 private int data; public Node(int data)&#123; this.leftChild = null; this.rightChild = null; this.data = data; &#125; &#125; 递归1234567891011121314151617181920212223242526272829/* *前序遍历二叉树 * */ public void preOrder(Node node)&#123; if(node != null)&#123; System.out.print(node.data); preOrder(node.leftChild); preOrder(node.rightChild); &#125; &#125; /* *中序遍历二叉树 * */ public void inOrder(Node node)&#123; if(node != null)&#123; inOrder(node.leftChild); System.out.print(node.data); inOrder(node.rightChild); &#125; &#125; /* *后序遍历二叉树 * */ public void postOrder(Node node)&#123; if(node != null)&#123; postOrder(node.leftChild); postOrder(node.rightChild); System.out.print(node.data); &#125; 非递归1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * * 【前序】 * 利用栈实现循环先序遍历二叉树 * 这种实现类似于图的深度优先遍历（DFS） * 维护一个栈，将根节点入栈，然后只要栈不为空，出栈并访问，接着依次将访问节点的右节点、左节点入栈。 * 这种方式应该是对先序遍历的一种特殊实现（看上去简单明了），但是不具备很好的扩展性，在中序和后序方式中不适用 */ public static void preOrderStack(Node root)&#123; if(root==null)return; Stack&lt;Node&gt; s=new Stack&lt;Node&gt;(); s.push(root); while(!s.isEmpty())&#123; Node temp=s.pop(); System.out.println(temp.value); if(temp.right!=null) s.push(temp.right); if(temp.left!=null) s.push(temp.left); &#125; &#125; /** * * 【中序】 * 利用栈模拟递归过程实现循环中序遍历二叉树 * 访问的时间是在左子树都处理完直到null的时候出栈并访问。 */ public static void inOrderStack(Node root)&#123; if(root==null)return; Stack&lt;Node&gt; s=new Stack&lt;Node&gt;(); while(root!=null||!s.isEmpty())&#123; while(root!=null)&#123; s.push(root);//先访问再入栈 root=root.left; &#125; root=s.pop(); System.out.println(root.value); root=root.right;//如果是null，出栈并处理右子树 &#125; &#125; /** * * 【后序】 * 后序遍历不同于先序和中序，它是要先处理完左右子树，然后再处理根(回溯)，所以需要一个记录哪些节点已经被访问的结构(可以在树结构里面加一个标记)，这里可以用map实现 */ public static void postOrderStack(Node root)&#123; if(root==null)return; Stack&lt;Node&gt; s=new Stack&lt;Node&gt;(); Map&lt;Node,Boolean&gt; map=new HashMap&lt;Node,Boolean&gt;(); s.push(root); while(!s.isEmpty())&#123; Node temp=s.peek(); if(temp.left!=null&amp;&amp;!map.containsKey(temp.left))&#123; temp=temp.left; while(temp!=null)&#123; if(map.containsKey(temp))break; else s.push(temp); temp=temp.left; &#125; continue; &#125; if(temp.right!=null&amp;&amp;!map.containsKey(temp.right))&#123; s.push(temp.right); continue; &#125; Node t=s.pop(); map.put(t,true); System.out.println(t.value); &#125; &#125; 广度优先遍历（层次遍历）123456789101112131415/** * @param root 树根节点 * 层序遍历二叉树，用队列实现，先将根节点入队列，只要队列不为空，然后出队列，并访问，接着讲访问节点的左右子树依次入队列 */ public static void levelTravel(Node root)&#123; if(root==null)return; Queue&lt;Node&gt; q=new LinkedList&lt;Node&gt;(); q.add(root); while(!q.isEmpty())&#123; Node temp = q.poll(); System.out.println(temp.value); if(temp.left!=null)q.add(temp.left); if(temp.right!=null)q.add(temp.right); &#125; &#125;","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"DiskLruCache","date":"2017-04-20T07:38:38.000Z","path":"2017/04/20/DiskLruCache/","text":"DiskLruCache类备份123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775/* * Copyright (C) 2011 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package libcore.io;import java.io.BufferedWriter;import java.io.Closeable;import java.io.EOFException;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileWriter;import java.io.FilterOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.io.Writer;import java.nio.charset.Charsets;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.LinkedHashMap;import java.util.Map;import java.util.concurrent.Callable;import java.util.concurrent.ExecutorService;import java.util.concurrent.LinkedBlockingQueue;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;/** * A cache that uses a bounded amount of space on a filesystem. Each cache * entry has a string key and a fixed number of values. Values are byte * sequences, accessible as streams or files. Each value must be between &#123;@code * 0&#125; and &#123;@code Integer.MAX_VALUE&#125; bytes in length. * * &lt;p&gt;The cache stores its data in a directory on the filesystem. This * directory must be exclusive to the cache; the cache may delete or overwrite * files from its directory. It is an error for multiple processes to use the * same cache directory at the same time. * * &lt;p&gt;This cache limits the number of bytes that it will store on the * filesystem. When the number of stored bytes exceeds the limit, the cache will * remove entries in the background until the limit is satisfied. The limit is * not strict: the cache may temporarily exceed it while waiting for files to be * deleted. The limit does not include filesystem overhead or the cache * journal so space-sensitive applications should set a conservative limit. * * &lt;p&gt;Clients call &#123;@link #edit&#125; to create or update the values of an entry. An * entry may have only one editor at one time; if a value is not available to be * edited then &#123;@link #edit&#125; will return null. * &lt;ul&gt; * &lt;li&gt;When an entry is being &lt;strong&gt;created&lt;/strong&gt; it is necessary to * supply a full set of values; the empty value should be used as a * placeholder if necessary. * &lt;li&gt;When an entry is being &lt;strong&gt;edited&lt;/strong&gt;, it is not necessary * to supply data for every value; values default to their previous * value. * &lt;/ul&gt; * Every &#123;@link #edit&#125; call must be matched by a call to &#123;@link Editor#commit&#125; * or &#123;@link Editor#abort&#125;. Committing is atomic: a read observes the full set * of values as they were before or after the commit, but never a mix of values. * * &lt;p&gt;Clients call &#123;@link #get&#125; to read a snapshot of an entry. The read will * observe the value at the time that &#123;@link #get&#125; was called. Updates and * removals after the call do not impact ongoing reads. * * &lt;p&gt;This class is tolerant of some I/O errors. If files are missing from the * filesystem, the corresponding entries will be dropped from the cache. If * an error occurs while writing a cache value, the edit will fail silently. * Callers should handle other problems by catching &#123;@code IOException&#125; and * responding appropriately. */public final class DiskLruCache implements Closeable &#123; static final String JOURNAL_FILE = &quot;journal&quot;; static final String JOURNAL_FILE_TMP = &quot;journal.tmp&quot;; static final String MAGIC = &quot;libcore.io.DiskLruCache&quot;; static final String VERSION_1 = &quot;1&quot;; static final long ANY_SEQUENCE_NUMBER = -1; private static final String CLEAN = &quot;CLEAN&quot;; private static final String DIRTY = &quot;DIRTY&quot;; private static final String REMOVE = &quot;REMOVE&quot;; private static final String READ = &quot;READ&quot;; /* * This cache uses a journal file named &quot;journal&quot;. A typical journal file * looks like this: * libcore.io.DiskLruCache * 1 * 100 * 2 * * CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 * DIRTY 335c4c6028171cfddfbaae1a9c313c52 * CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342 * REMOVE 335c4c6028171cfddfbaae1a9c313c52 * DIRTY 1ab96a171faeeee38496d8b330771a7a * CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234 * READ 335c4c6028171cfddfbaae1a9c313c52 * READ 3400330d1dfc7f3f7f4b8d4d803dfcf6 * * The first five lines of the journal form its header. They are the * constant string &quot;libcore.io.DiskLruCache&quot;, the disk cache&apos;s version, * the application&apos;s version, the value count, and a blank line. * * Each of the subsequent lines in the file is a record of the state of a * cache entry. Each line contains space-separated values: a state, a key, * and optional state-specific values. * o DIRTY lines track that an entry is actively being created or updated. * Every successful DIRTY action should be followed by a CLEAN or REMOVE * action. DIRTY lines without a matching CLEAN or REMOVE indicate that * temporary files may need to be deleted. * o CLEAN lines track a cache entry that has been successfully published * and may be read. A publish line is followed by the lengths of each of * its values. * o READ lines track accesses for LRU. * o REMOVE lines track entries that have been deleted. * * The journal file is appended to as cache operations occur. The journal may * occasionally be compacted by dropping redundant lines. A temporary file named * &quot;journal.tmp&quot; will be used during compaction; that file should be deleted if * it exists when the cache is opened. */ private final File directory; private final File journalFile; private final File journalFileTmp; private final int appVersion; private final long maxSize; private final int valueCount; private long size = 0; private Writer journalWriter; private final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;String, Entry&gt;(0, 0.75f, true); private int redundantOpCount; /** * To differentiate between old and current snapshots, each entry is given * a sequence number each time an edit is committed. A snapshot is stale if * its sequence number is not equal to its entry&apos;s sequence number. */ private long nextSequenceNumber = 0; /** This cache uses a single background thread to evict entries. */ private final ExecutorService executorService = new ThreadPoolExecutor(0, 1, 60L, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); private final Callable&lt;Void&gt; cleanupCallable = new Callable&lt;Void&gt;() &#123; @Override public Void call() throws Exception &#123; synchronized (DiskLruCache.this) &#123; if (journalWriter == null) &#123; return null; // closed &#125; trimToSize(); if (journalRebuildRequired()) &#123; rebuildJournal(); redundantOpCount = 0; &#125; &#125; return null; &#125; &#125;; private DiskLruCache(File directory, int appVersion, int valueCount, long maxSize) &#123; this.directory = directory; this.appVersion = appVersion; this.journalFile = new File(directory, JOURNAL_FILE); this.journalFileTmp = new File(directory, JOURNAL_FILE_TMP); this.valueCount = valueCount; this.maxSize = maxSize; &#125; /** * Opens the cache in &#123;@code directory&#125;, creating a cache if none exists * there. * * @param directory a writable directory * @param appVersion * @param valueCount the number of values per cache entry. Must be positive. * @param maxSize the maximum number of bytes this cache should use to store * @throws IOException if reading or writing the cache directory fails */ public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) throws IOException &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException(&quot;maxSize &lt;= 0&quot;); &#125; if (valueCount &lt;= 0) &#123; throw new IllegalArgumentException(&quot;valueCount &lt;= 0&quot;); &#125; // prefer to pick up where we left off DiskLruCache cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); if (cache.journalFile.exists()) &#123; try &#123; cache.readJournal(); cache.processJournal(); cache.journalWriter = new BufferedWriter(new FileWriter(cache.journalFile, true)); return cache; &#125; catch (IOException journalIsCorrupt) &#123; System.logW(&quot;DiskLruCache &quot; + directory + &quot; is corrupt: &quot; + journalIsCorrupt.getMessage() + &quot;, removing&quot;); cache.delete(); &#125; &#125; // create a new empty cache directory.mkdirs(); cache = new DiskLruCache(directory, appVersion, valueCount, maxSize); cache.rebuildJournal(); return cache; &#125; private void readJournal() throws IOException &#123; StrictLineReader reader = new StrictLineReader(new FileInputStream(journalFile), Charsets.US_ASCII); try &#123; String magic = reader.readLine(); String version = reader.readLine(); String appVersionString = reader.readLine(); String valueCountString = reader.readLine(); String blank = reader.readLine(); if (!MAGIC.equals(magic) || !VERSION_1.equals(version) || !Integer.toString(appVersion).equals(appVersionString) || !Integer.toString(valueCount).equals(valueCountString) || !&quot;&quot;.equals(blank)) &#123; throw new IOException(&quot;unexpected journal header: [&quot; + magic + &quot;, &quot; + version + &quot;, &quot; + valueCountString + &quot;, &quot; + blank + &quot;]&quot;); &#125; int lineCount = 0; while (true) &#123; try &#123; readJournalLine(reader.readLine()); lineCount++; &#125; catch (EOFException endOfJournal) &#123; break; &#125; &#125; redundantOpCount = lineCount - lruEntries.size(); &#125; finally &#123; IoUtils.closeQuietly(reader); &#125; &#125; private void readJournalLine(String line) throws IOException &#123; int firstSpace = line.indexOf(&apos; &apos;); if (firstSpace == -1) &#123; throw new IOException(&quot;unexpected journal line: &quot; + line); &#125; int keyBegin = firstSpace + 1; int secondSpace = line.indexOf(&apos; &apos;, keyBegin); final String key; if (secondSpace == -1) &#123; key = line.substring(keyBegin); if (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123; lruEntries.remove(key); return; &#125; &#125; else &#123; key = line.substring(keyBegin, secondSpace); &#125; Entry entry = lruEntries.get(key); if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; if (secondSpace != -1 &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123; String[] parts = line.substring(secondSpace + 1).split(&quot; &quot;); entry.readable = true; entry.currentEditor = null; entry.setLengths(parts); &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123; entry.currentEditor = new Editor(entry); &#125; else if (secondSpace == -1 &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123; // this work was already done by calling lruEntries.get() &#125; else &#123; throw new IOException(&quot;unexpected journal line: &quot; + line); &#125; &#125; /** * Computes the initial size and collects garbage as a part of opening the * cache. Dirty entries are assumed to be inconsistent and will be deleted. */ private void processJournal() throws IOException &#123; deleteIfExists(journalFileTmp); for (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123; Entry entry = i.next(); if (entry.currentEditor == null) &#123; for (int t = 0; t &lt; valueCount; t++) &#123; size += entry.lengths[t]; &#125; &#125; else &#123; entry.currentEditor = null; for (int t = 0; t &lt; valueCount; t++) &#123; deleteIfExists(entry.getCleanFile(t)); deleteIfExists(entry.getDirtyFile(t)); &#125; i.remove(); &#125; &#125; &#125; /** * Creates a new journal that omits redundant information. This replaces the * current journal if it exists. */ private synchronized void rebuildJournal() throws IOException &#123; if (journalWriter != null) &#123; journalWriter.close(); &#125; Writer writer = new BufferedWriter(new FileWriter(journalFileTmp)); writer.write(MAGIC); writer.write(&quot;\\n&quot;); writer.write(VERSION_1); writer.write(&quot;\\n&quot;); writer.write(Integer.toString(appVersion)); writer.write(&quot;\\n&quot;); writer.write(Integer.toString(valueCount)); writer.write(&quot;\\n&quot;); writer.write(&quot;\\n&quot;); for (Entry entry : lruEntries.values()) &#123; if (entry.currentEditor != null) &#123; writer.write(DIRTY + &apos; &apos; + entry.key + &apos;\\n&apos;); &#125; else &#123; writer.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\\n&apos;); &#125; &#125; writer.close(); journalFileTmp.renameTo(journalFile); journalWriter = new BufferedWriter(new FileWriter(journalFile, true)); &#125; private static void deleteIfExists(File file) throws IOException &#123; try &#123; Libcore.os.remove(file.getPath()); &#125; catch (ErrnoException errnoException) &#123; if (errnoException.errno != OsConstants.ENOENT) &#123; throw errnoException.rethrowAsIOException(); &#125; &#125; &#125; /** * Returns a snapshot of the entry named &#123;@code key&#125;, or null if it doesn&apos;t * exist is not currently readable. If a value is returned, it is moved to * the head of the LRU queue. */ public synchronized Snapshot get(String key) throws IOException &#123; checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null) &#123; return null; &#125; if (!entry.readable) &#123; return null; &#125; /* * Open all streams eagerly to guarantee that we see a single published * snapshot. If we opened streams lazily then the streams could come * from different edits. */ InputStream[] ins = new InputStream[valueCount]; try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; ins[i] = new FileInputStream(entry.getCleanFile(i)); &#125; &#125; catch (FileNotFoundException e) &#123; // a file must have been deleted manually! return null; &#125; redundantOpCount++; journalWriter.append(READ + &apos; &apos; + key + &apos;\\n&apos;); if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; return new Snapshot(key, entry.sequenceNumber, ins); &#125; /** * Returns an editor for the entry named &#123;@code key&#125;, or null if another * edit is in progress. */ public Editor edit(String key) throws IOException &#123; return edit(key, ANY_SEQUENCE_NUMBER); &#125; private synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // snapshot is stale &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; else if (entry.currentEditor != null) &#123; return null; // another edit is in progress &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; // flush the journal before creating files to prevent file leaks journalWriter.write(DIRTY + &apos; &apos; + key + &apos;\\n&apos;); journalWriter.flush(); return editor; &#125; /** * Returns the directory where this cache stores its data. */ public File getDirectory() &#123; return directory; &#125; /** * Returns the maximum number of bytes that this cache should use to store * its data. */ public long maxSize() &#123; return maxSize; &#125; /** * Returns the number of bytes currently being used to store the values in * this cache. This may be greater than the max size if a background * deletion is pending. */ public synchronized long size() &#123; return size; &#125; private synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; // if this edit is creating the entry for the first time, every index must have a value if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException(&quot;Newly created entry didn&apos;t create value for index &quot; + i); &#125; if (!entry.getDirtyFile(i).exists()) &#123; editor.abort(); System.logW(&quot;DiskLruCache: Newly created entry doesn&apos;t have file for index &quot; + i); return; &#125; &#125; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.getDirtyFile(i); if (success) &#123; if (dirty.exists()) &#123; File clean = entry.getCleanFile(i); dirty.renameTo(clean); long oldLength = entry.lengths[i]; long newLength = clean.length(); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; deleteIfExists(dirty); &#125; &#125; redundantOpCount++; entry.currentEditor = null; if (entry.readable | success) &#123; entry.readable = true; journalWriter.write(CLEAN + &apos; &apos; + entry.key + entry.getLengths() + &apos;\\n&apos;); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.write(REMOVE + &apos; &apos; + entry.key + &apos;\\n&apos;); &#125; if (size &gt; maxSize || journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; &#125; /** * We only rebuild the journal when it will halve the size of the journal * and eliminate at least 2000 ops. */ private boolean journalRebuildRequired() &#123; final int REDUNDANT_OP_COMPACT_THRESHOLD = 2000; return redundantOpCount &gt;= REDUNDANT_OP_COMPACT_THRESHOLD &amp;&amp; redundantOpCount &gt;= lruEntries.size(); &#125; /** * Drops the entry for &#123;@code key&#125; if it exists and can be removed. Entries * actively being edited cannot be removed. * * @return true if an entry was removed. */ public synchronized boolean remove(String key) throws IOException &#123; checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null || entry.currentEditor != null) &#123; return false; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; File file = entry.getCleanFile(i); if (!file.delete()) &#123; throw new IOException(&quot;failed to delete &quot; + file); &#125; size -= entry.lengths[i]; entry.lengths[i] = 0; &#125; redundantOpCount++; journalWriter.append(REMOVE + &apos; &apos; + key + &apos;\\n&apos;); lruEntries.remove(key); if (journalRebuildRequired()) &#123; executorService.submit(cleanupCallable); &#125; return true; &#125; /** * Returns true if this cache has been closed. */ public boolean isClosed() &#123; return journalWriter == null; &#125; private void checkNotClosed() &#123; if (journalWriter == null) &#123; throw new IllegalStateException(&quot;cache is closed&quot;); &#125; &#125; /** * Force buffered operations to the filesystem. */ public synchronized void flush() throws IOException &#123; checkNotClosed(); trimToSize(); journalWriter.flush(); &#125; /** * Closes this cache. Stored values will remain on the filesystem. */ public synchronized void close() throws IOException &#123; if (journalWriter == null) &#123; return; // already closed &#125; for (Entry entry : new ArrayList&lt;Entry&gt;(lruEntries.values())) &#123; if (entry.currentEditor != null) &#123; entry.currentEditor.abort(); &#125; &#125; trimToSize(); journalWriter.close(); journalWriter = null; &#125; private void trimToSize() throws IOException &#123; while (size &gt; maxSize) &#123; Map.Entry&lt;String, Entry&gt; toEvict = lruEntries.eldest(); remove(toEvict.getKey()); &#125; &#125; /** * Closes the cache and deletes all of its stored values. This will delete * all files in the cache directory including files that weren&apos;t created by * the cache. */ public void delete() throws IOException &#123; close(); IoUtils.deleteContents(directory); &#125; private void validateKey(String key) &#123; if (key.contains(&quot; &quot;) || key.contains(&quot;\\n&quot;) || key.contains(&quot;\\r&quot;)) &#123; throw new IllegalArgumentException( &quot;keys must not contain spaces or newlines: \\&quot;&quot; + key + &quot;\\&quot;&quot;); &#125; &#125; private static String inputStreamToString(InputStream in) throws IOException &#123; return Streams.readFully(new InputStreamReader(in, Charsets.UTF_8)); &#125; /** * A snapshot of the values for an entry. */ public final class Snapshot implements Closeable &#123; private final String key; private final long sequenceNumber; private final InputStream[] ins; private Snapshot(String key, long sequenceNumber, InputStream[] ins) &#123; this.key = key; this.sequenceNumber = sequenceNumber; this.ins = ins; &#125; /** * Returns an editor for this snapshot&apos;s entry, or null if either the * entry has changed since this snapshot was created or if another edit * is in progress. */ public Editor edit() throws IOException &#123; return DiskLruCache.this.edit(key, sequenceNumber); &#125; /** * Returns the unbuffered stream with the value for &#123;@code index&#125;. */ public InputStream getInputStream(int index) &#123; return ins[index]; &#125; /** * Returns the string value for &#123;@code index&#125;. */ public String getString(int index) throws IOException &#123; return inputStreamToString(getInputStream(index)); &#125; @Override public void close() &#123; for (InputStream in : ins) &#123; IoUtils.closeQuietly(in); &#125; &#125; &#125; /** * Edits the values for an entry. */ public final class Editor &#123; private final Entry entry; private final boolean[] written; private boolean hasErrors; private Editor(Entry entry) &#123; this.entry = entry; this.written = (entry.readable) ? null : new boolean[valueCount]; &#125; /** * Returns an unbuffered input stream to read the last committed value, * or null if no value has been committed. */ public InputStream newInputStream(int index) throws IOException &#123; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; return null; &#125; return new FileInputStream(entry.getCleanFile(index)); &#125; &#125; /** * Returns the last committed value as a string, or null if no value * has been committed. */ public String getString(int index) throws IOException &#123; InputStream in = newInputStream(index); return in != null ? inputStreamToString(in) : null; &#125; /** * Returns a new unbuffered output stream to write the value at * &#123;@code index&#125;. If the underlying output stream encounters errors * when writing to the filesystem, this edit will be aborted when * &#123;@link #commit&#125; is called. The returned output stream does not throw * IOExceptions. */ public OutputStream newOutputStream(int index) throws IOException &#123; synchronized (DiskLruCache.this) &#123; if (entry.currentEditor != this) &#123; throw new IllegalStateException(); &#125; if (!entry.readable) &#123; written[index] = true; &#125; return new FaultHidingOutputStream(new FileOutputStream(entry.getDirtyFile(index))); &#125; &#125; /** * Sets the value at &#123;@code index&#125; to &#123;@code value&#125;. */ public void set(int index, String value) throws IOException &#123; Writer writer = null; try &#123; writer = new OutputStreamWriter(newOutputStream(index), Charsets.UTF_8); writer.write(value); &#125; finally &#123; IoUtils.closeQuietly(writer); &#125; &#125; /** * Commits this edit so it is visible to readers. This releases the * edit lock so another edit may be started on the same key. */ public void commit() throws IOException &#123; if (hasErrors) &#123; completeEdit(this, false); remove(entry.key); // the previous entry is stale &#125; else &#123; completeEdit(this, true); &#125; &#125; /** * Aborts this edit. This releases the edit lock so another edit may be * started on the same key. */ public void abort() throws IOException &#123; completeEdit(this, false); &#125; private class FaultHidingOutputStream extends FilterOutputStream &#123; private FaultHidingOutputStream(OutputStream out) &#123; super(out); &#125; @Override public void write(int oneByte) &#123; try &#123; out.write(oneByte); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; @Override public void write(byte[] buffer, int offset, int length) &#123; try &#123; out.write(buffer, offset, length); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; @Override public void close() &#123; try &#123; out.close(); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; @Override public void flush() &#123; try &#123; out.flush(); &#125; catch (IOException e) &#123; hasErrors = true; &#125; &#125; &#125; &#125; private final class Entry &#123; private final String key; /** Lengths of this entry&apos;s files. */ private final long[] lengths; /** True if this entry has ever been published */ private boolean readable; /** The ongoing edit or null if this entry is not being edited. */ private Editor currentEditor; /** The sequence number of the most recently committed edit to this entry. */ private long sequenceNumber; private Entry(String key) &#123; this.key = key; this.lengths = new long[valueCount]; &#125; public String getLengths() throws IOException &#123; StringBuilder result = new StringBuilder(); for (long size : lengths) &#123; result.append(&apos; &apos;).append(size); &#125; return result.toString(); &#125; /** * Set lengths using decimal numbers like &quot;10123&quot;. */ private void setLengths(String[] strings) throws IOException &#123; if (strings.length != valueCount) &#123; throw invalidLengths(strings); &#125; try &#123; for (int i = 0; i &lt; strings.length; i++) &#123; lengths[i] = Long.parseLong(strings[i]); &#125; &#125; catch (NumberFormatException e) &#123; throw invalidLengths(strings); &#125; &#125; private IOException invalidLengths(String[] strings) throws IOException &#123; throw new IOException(&quot;unexpected journal line: &quot; + Arrays.toString(strings)); &#125; public File getCleanFile(int i) &#123; return new File(directory, key + &quot;.&quot; + i); &#125; public File getDirtyFile(int i) &#123; return new File(directory, key + &quot;.&quot; + i + &quot;.tmp&quot;); &#125; &#125;&#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"解决httpclient和httpcore的冲突问题","date":"2017-04-10T02:45:05.000Z","path":"2017/04/10/solve-httpclient-httpcore-clash/","text":"虽然在Android2.2版本之前使用HttpClient是较好的选择；而在Android2.3 之后HttpUrlConnection是较好的选择。在Android6.0中HttpClient已被移除，使用的不是很多。但是最近在学习做一个网络框架，同时使用HttpClient和HttpURLConnect。但是在使用HttpClient和HttpCore两个包时，会有冲突，备份一下解决方法 解决方法在build.gradle的android中增加一下代码,即可解决冲突问题123456789101112packagingOptions &#123; exclude &apos;META-INF/DEPENDENCIES.txt&apos; exclude &apos;META-INF/LICENSE.txt&apos; exclude &apos;META-INF/NOTICE.txt&apos; exclude &apos;META-INF/NOTICE&apos; exclude &apos;META-INF/LICENSE&apos; exclude &apos;META-INF/DEPENDENCIES&apos; exclude &apos;META-INF/notice.txt&apos; exclude &apos;META-INF/license.txt&apos; exclude &apos;META-INF/dependencies.txt&apos; exclude &apos;META-INF/LGPL2.1&apos; &#125;","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"四天做一个Android小说更新提醒APP#i·Novel#","date":"2017-04-03T14:53:42.000Z","path":"2017/04/03/iNovel/","text":"你是否喜欢看网络小说？是否一遍遍的去刷新网页查看小说是否更新？你是否迫切的想要一款app自动获取小说的更新情况并发出通知提醒？ 三天假期就快结束了，首先祝大家玩得开心。 更新 增加图片缓存功能为了节省流量，在图片加载的增加缓存功能，这里使用的DiskLruCache缓存到本地存储，而未使用Picasso的自带缓存。因为DiskLruCache不是包含在AndroidAPI中，需要手动下载下载地址：(需要使用google,无法打开google，请到另一片博文中获取)DiskLruCache类获取地址无法登陆Google点击这里DiskLruCache具体使用在Android官方教程中说的很清楚，这里不再叙述。这里是Android官网关于图片缓存的资料，包含内存缓存Use a Memory Cache和磁盘缓存Use a Disk Cacheandroid图片缓存官方资料在小说更新详情UpdateAdapter类中，先判断本地缓存是否有图片，有图片则直接加载，无图片则从Picasso加载123456789101112131415161718//先判断磁盘缓存中是否有图片，有图片则直接加载，无图片则从Picasso加载 if(!CacheUtil.getBitmap(diskLruCache,&quot;https:&quot;+bookUpdateList.get(getPosition).imgUrl,holder.book_img)) &#123; Log.d(&quot;test&quot;,&quot;getBitmap with Picasso&quot;); Picasso.with(context).load(&quot;https:&quot;+bookUpdateList.get(position).imgUrl).into(holder.book_img,new com.squareup.picasso.Callback()&#123; @Override public void onSuccess() &#123; //获取图片并缓存到磁盘 bitmap=((BitmapDrawable)holder.book_img.getDrawable()).getBitmap(); CacheUtil.saveBitmap(diskLruCache,&quot;https:&quot;+bookUpdateList.get(getPosition).imgUrl,bitmap); &#125; @Override public void onError() &#123; &#125; &#125;); &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Created by dnw on 2017/4/20. */public class CacheUtil &#123; /** * 获取磁盘路径 * @param context * @param uniqueName * @return */ public static File getDiskCacheDir(Context context, String uniqueName)&#123; String cachePath; if (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageRemovable()) &#123; cachePath = context.getExternalCacheDir().getPath(); &#125; else &#123; cachePath = context.getCacheDir().getPath(); &#125; return new File(cachePath + File.separator + uniqueName); &#125; /** * 获取版本号 * @param context * @return */ public static int getAppVersion(Context context) &#123; try &#123; PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(), 0); return info.versionCode; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; return 1; &#125; /** * * @param key * @return */ public static String hashKeyForDisk(String key) &#123; String cacheKey; try &#123; final MessageDigest mDigest = MessageDigest.getInstance(&quot;MD5&quot;); mDigest.update(key.getBytes()); cacheKey = bytesToHexString(mDigest.digest()); &#125; catch (NoSuchAlgorithmException e) &#123; cacheKey = String.valueOf(key.hashCode()); &#125; return cacheKey; &#125; private static String bytesToHexString(byte[] bytes) &#123; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; bytes.length; i++) &#123; String hex = Integer.toHexString(0xFF &amp; bytes[i]); if (hex.length() == 1) &#123; sb.append(&apos;0&apos;); &#125; sb.append(hex); &#125; return sb.toString(); &#125; /** * 缓存到磁盘 * @param mDiskLruCache * @param url * @param bitmap * @return */ public static boolean saveBitmap(DiskLruCache mDiskLruCache, String url, Bitmap bitmap) &#123; String key = hashKeyForDisk(url); try &#123; DiskLruCache.Editor editor = mDiskLruCache.edit(key); if(editor!=null) &#123; OutputStream outputStream = editor.newOutputStream(0); bitmap.compress(Bitmap.CompressFormat.PNG,90,outputStream); editor.commit(); &#125; &#125;catch(IOException e) &#123; e.printStackTrace(); &#125; return false; &#125; /** * 在磁盘中获取图片 * @param mDiskLruCache * @param url * @param imageView * @return */ public static boolean getBitmap(DiskLruCache mDiskLruCache, String url, ImageView imageView) &#123; try &#123; Log.d(&quot;test&quot;,&quot;in getBitmap&quot;); String key = hashKeyForDisk(url); DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key); if (snapShot != null) &#123; InputStream is = snapShot.getInputStream(0); Bitmap bitmap = BitmapFactory.decodeStream(is); imageView.setImageBitmap(bitmap); Log.d(&quot;test&quot;,&quot;getBitmap ok&quot;); return true; &#125;else &#123; return false; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return false; &#125;&#125; 前言自己有看小说的习惯，但是有时小说是否更新需要一遍遍的去刷新网页，耗时费神。最近一段时间忙于找实习面试看Android的一些知识。萌生了做一个提醒小说更新的app，顺便把最近看到学到的知识用上，既能方便自己又能巩固所学。 项目地址：https://github.com/hells0302/i-Nonel 效果图如下所示： 功能需求因为自己一直看小说，获取更新的问题之前也想过。主要有以下几点需求： 正确获取小说更新情况 能够同时显示多个小说的更新情况 可以保存小说列表以后自动获取 后台根据设置的时间间隔自动刷新并发出通知 夜间模式 通知栏、震动、呼吸灯提醒 以上几个需求主要涉及了UI，网络，数据存储，后台服务，传感器使用等 可行性分析首要的问题是怎么获取小数更新数据。这里使用了开源框架Jsoup。Jsoup官网摘抄官网简介介绍一下 jsoup is a Java library for working with real-world HTML. It provides a very convenient API for extracting and manipulating data, using the best of DOM, CSS, and jquery-like methods.jsoup implements the WHATWG HTML5 specification, and parses HTML to the same DOM as modern browsers do. scrape and parse HTML from a URL, file, or string find and extract data, using DOM traversal or CSS selectors manipulate the HTML elements, attributes, and text clean user-submitted content against a safe white-list, to prevent XSS attacks output tidy HTMLjsoup is designed to deal with all varieties of HTML found in the wild; from pristine and validating, to invalid tag-soup; jsoup will create a sensible parse tree. 通过Jsoup获取整个网页的数据，完后分析得到自己想要的数据。现阶段只做了一个小说网站的解析工作。小说封面图片的获取使用的开源框架picasso，加载图片非常快。 UI实验室没有做UI涉及的，参考做前端的大神给的建议，自己完成UI。期间也使用PS修图获取颜色代码等。推荐大家一个网站，上面的图标做的非常好。 Material iconshttps://material.io/icons/ 整体分析整个项目结构是按照功能进行分包的，这样以后修改的时候方便查找。工程监理号后，需要导入一下第三方开源库，如下图所示12345678910dependencies &#123; compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;) testCompile &apos;junit:junit:4.12&apos; compile &apos;com.android.support:appcompat-v7:25.1.1&apos; compile &apos;com.android.support:preference-v14:25.1.1&apos; compile &apos;com.android.support:design:25.1.1&apos; compile &apos;com.android.support:cardview-v7:25.1.1&apos; compile files(&apos;libs/jsoup-1.10.2.jar&apos;) compile files(&apos;libs/picasso-2.5.2.jar&apos;)&#125; 之前选择网络框架的时候，打算先使用Android-async-http，volley，OkHttp中的一个先把网页获取下来，然后再利用Jsoup解析，在上班之余，做的这个app，投了个懒直接使用了Jsoup获取网页。 首先先把网页请求，数据获取的工具类写完。常量类Constant，数据获取类HtmlParserUtil，和网络状态检测类NetworkState类 bean下的实体类Book和CacheBook，分别保存获取到的小说的一些信息，如小说名，作者，简介，图片Url，更新时间等 Application的实现，用来获取全局context以及后面的夜间模式 小说更新情况显示，小说添加，删除用到的ListView以及相应的adapter的实现 后台服务，以及后台服务中的Notification，以及才重新启动service用的BroadcastReceiver 刷新间隔使用了Android的Alarm机制 设置界面则是使用了Activity+PreferenceFragment的模式这里需要重点说明一下的是，数据库创建时使用了单例模式,关于单例模式的使用以及原理以后再详细阐述，这里不再过多描述。12345678910111213private DatabaseUtil(Context context) &#123; DatabaseHelper dbHelper=new DatabaseHelper(context,DB_NAME,null,VERSION); db=dbHelper.getWritableDatabase(); &#125; public synchronized static DatabaseUtil getInstance(Context context) &#123; if(databaseUtil==null) &#123; databaseUtil=new DatabaseUtil(context); &#125; return databaseUtil; &#125; 界面编写主页显示小说更新详情主要分为有图模式和无图模式主要说一下几个比较特殊的控件，其他具体请到GitHub下载代码。MainActivity中主要使用了DrawerLayout，SwipeRefreshLayout，Toolbar，NavigationView等实现导航栏，下拉刷新，侧滑导航等功能对应的布局如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawer_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; tools:openDrawer=&quot;start&quot;&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:id=&quot;@+id/main&quot; &gt; &lt;ProgressBar android:layout_marginTop=&quot;100dp&quot; android:layout_centerHorizontal=&quot;true&quot; android:id=&quot;@+id/pb&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:visibility=&quot;gone&quot; /&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;RelativeLayout android:id=&quot;@+id/titleBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; &gt; &lt;android.support.v7.widget.Toolbar android:gravity=&quot;center_vertical&quot; android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot; app:title=&quot; I·Novel&quot; android:minHeight=&quot;40dp&quot;&gt; &lt;ImageView android:onClick=&quot;update&quot; android:paddingRight=&quot;5dp&quot; android:layout_gravity=&quot;right&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:src=&quot;@drawable/ic_autorenew_white_24dp&quot;/&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/RelativeLayout&gt; &lt;android.support.v4.widget.SwipeRefreshLayout android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; android:id=&quot;@+id/refreshLayout&quot;&gt; &lt;ListView android:id=&quot;@+id/listView&quot; android:dividerHeight=&quot;8dp&quot; android:divider=&quot;@null&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/android.support.v4.widget.SwipeRefreshLayout&gt; &lt;/LinearLayout&gt; &lt;/RelativeLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav_view&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/nav_header&quot; app:menu=&quot;@menu/drawer&quot; android:fitsSystemWindows=&quot;true&quot; /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; ListView中显示小说更新的布局，这里用了CardView更美观一些123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.v7.widget.CardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_height=&quot;96dp&quot; android:layout_width=&quot;match_parent&quot; android:focusable=&quot;true&quot; android:clickable=&quot;true&quot; android:foreground=&quot;?android:attr/selectableItemBackground&quot; app:cardCornerRadius=&quot;4dp&quot; app:cardElevation=&quot;1dp&quot; app:cardPreventCornerOverlap=&quot;true&quot; android:layout_marginTop=&quot;8dp&quot; android:layout_marginLeft=&quot;8dp&quot; android:layout_marginRight=&quot;8dp&quot;&gt; &lt;LinearLayout android:paddingLeft=&quot;8dp&quot; android:paddingRight=&quot;8dp&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:layout_marginTop=&quot;8dp&quot; android:layout_marginBottom=&quot;8dp&quot; android:id=&quot;@+id/book_img&quot; android:layout_width=&quot;80dp&quot; android:layout_height=&quot;100dp&quot; android:src=&quot;@drawable/bookimg&quot;/&gt; &lt;LinearLayout android:orientation=&quot;vertical&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_marginTop=&quot;8dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:id=&quot;@+id/book_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;16sp&quot; android:textStyle=&quot;bold&quot; android:text=&quot;圣墟&quot;/&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:id=&quot;@+id/author&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;辰东&quot;/&gt; &lt;TextView android:paddingLeft=&quot;10dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;著&quot;/&gt; &lt;/LinearLayout&gt; &lt;TextView android:layout_marginTop=&quot;10dp&quot; android:layout_marginLeft=&quot;10dp&quot; android:id=&quot;@+id/info&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;在破败中崛起，在寂灭中复苏。沧海成尘，雷电枯竭……&quot;/&gt; &lt;LinearLayout android:paddingLeft=&quot;10dp&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;最近更新：&quot;/&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:id=&quot;@+id/update_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;第三百零六章 难解&quot;/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:paddingLeft=&quot;10dp&quot; android:layout_marginTop=&quot;3dp&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;更新时间：&quot;/&gt; &lt;TextView android:layout_gravity=&quot;bottom&quot; android:id=&quot;@+id/update_time&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:singleLine=&quot;true&quot; android:text=&quot;今天18:16更新&quot;/&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/android.support.v7.widget.CardView&gt; 设置界面使用了PreferenceFragment对应的布局和Preference的xml如下用FrameLayout来放置碎片布局12345678910111213141516171819202122&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;android.support.v7.widget.Toolbar android:gravity=&quot;center_vertical&quot; android:id=&quot;@+id/setting_toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;40dp&quot; android:background=&quot;?attr/colorPrimary&quot; android:theme=&quot;@style/AppTheme.AppBarOverlay&quot; app:title=&quot; 设置&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;FrameLayout android:id=&quot;@+id/frameLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot;&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 设置的想用参数用PreferenceScreen设置，提供了SharedPreferences存储，无需手动设置123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;PreferenceScreen xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt; &lt;PreferenceCategory android:title=&quot;基本设置&quot;&gt; &lt;CheckBoxPreference android:title=&quot;无图模式&quot; android:key=&quot;no_picture_mode&quot; android:defaultValue=&quot;false&quot; android:summary=&quot;首页不显示小说图片&quot; /&gt; &lt;ListPreference android:title=&quot;刷新时间&quot; android:key=&quot;time_of_refresh&quot; android:entries=&quot;@array/time_to_refresh_pots&quot; android:dialogTitle=&quot;请选择刷新时间&quot; android:entryValues=&quot;@array/time_to_refresh&quot; android:defaultValue=&quot;6&quot;/&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=&quot;通知提醒设置&quot;&gt; &lt;CheckBoxPreference android:title=&quot;震动&quot; android:key=&quot;vibrator_mode&quot; android:defaultValue=&quot;false&quot; android:summary=&quot;设置是否震动提醒&quot; /&gt; &lt;CheckBoxPreference android:title=&quot;呼吸灯&quot; android:key=&quot;light_mode&quot; android:defaultValue=&quot;false&quot; android:summary=&quot;设置呼吸灯闪烁提醒&quot; /&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; 其他布局大体相似，具体请到GitHub下载源码 刷新数据&amp;&amp;本地化数据在小说添加界面所添加的小说绘存到相应的数据库表里实现数据本地化为了节省流量以及刷新的时间，把获取小说链接地址的网络请求和获取小说更新详情的网络请求分别开来。获取小说更新详情的网络请求很频繁，而获取小说链接地址在添加小说或者删除小说时才需要获取。1234567891011121314151617181920212223242526272829303132333435363738394041/** * 根据添加的小说获取小说详情链接地址 */public void updateNovelInfoLink()&#123; //如果添加的小说数量为0，则表示已删除所有小说，清空数据库缓存 if(databaseUtil.getNovelLinkCount()==0) &#123; databaseUtil.delNovelInfoLinkElement(); refresh(); &#125; //当添加的小说总数和获取到的小说链接总数不同，说明再次添加小说或者删除小说，刷新 if(databaseUtil.getNovelInfoLinkCount()!=databaseUtil.getNovelLinkCount()) &#123; databaseUtil.delNovelInfoLinkElement(); if(NetworkState.networkConnected(MainActivity.this)&amp;&amp;(NetworkState.wifiConnected(MainActivity.this)||NetworkState.mobileDataConnected(MainActivity.this))) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Map&lt;String,String&gt; map; Iterator iterator; List&lt;Map&lt;String,String&gt;&gt; listLinks=databaseUtil.getNovelLinkElement(); for(int i=0;i&lt;listLinks.size();i++)&#123; map=listLinks.get(i); iterator=map.keySet().iterator(); String name=(String)iterator.next(); String tmpUrl1=map.get(name); String tmpUrl2=HtmlParserUtil.getNovelLink(tmpUrl1); databaseUtil.addLinkToNovelInfoLink(name,&quot;http:&quot;+tmpUrl2); &#125; refresh(); &#125; &#125;).start(); &#125; &#125;else &#123; refresh(); &#125;&#125; 获取小说更新详情12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 刷新更新内容 */ public void refresh() &#123; //更新UI runOnUiThread(new Runnable() &#123; @Override public void run() &#123; swipeRefreshLayout.setRefreshing(true); &#125; &#125;); //获取数据库中小说链接总数 int count=databaseUtil.getNovelInfoLinkCount(); //更新时防止listview重复显示 if(list.size()&gt;0) &#123; list.clear(); &#125; //数据库中小说链接总数为0，说明未添加小说 if(count==0) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; swipeRefreshLayout.setRefreshing(false); adapter.notifyDataSetChanged(); &#125; &#125;); Toast.makeText(MainActivity.this,&quot;还未添加小说，请先添加小说&quot;,Toast.LENGTH_SHORT).show(); &#125;else &#123; //有网络是更新 if(NetworkState.networkConnected(MainActivity.this)&amp;&amp;(NetworkState.wifiConnected(MainActivity.this)||NetworkState.mobileDataConnected(MainActivity.this))) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; if(list.size()&gt;0) &#123; list.clear(); &#125; //获取小说链接地址 List&lt;String&gt; list12= databaseUtil.getNovelInfoLinkElement(); for(int i=0;i&lt;list12.size();i++) &#123; Book book=HtmlParserUtil.getUpdateInfo(list12.get(i)); list.add(book); &#125; handler.sendEmptyMessage(0x123); &#125; &#125;).start(); &#125;else &#123; Toast.makeText(MainActivity.this,&quot;无网络连接，请检查...&quot;,Toast.LENGTH_SHORT).show(); &#125; &#125; &#125; 显示数据因为使用里ListView显示，所以首先需要一个adapter，在adapter中根据设置页面是否是无图模式，选择是否加载图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * Created by dnw on 2017/3/31. */public class UpdateAdapter extends BaseAdapter&#123; public Context context; public List&lt;Book&gt; bookUpdateList; SharedPreferences sharedPreferences; public UpdateAdapter(Context context, List&lt;Book&gt; list) &#123; this.context=context; this.bookUpdateList=list; &#125; @Override public int getCount() &#123; return bookUpdateList.size(); &#125; @Override public Object getItem(int position) &#123; return bookUpdateList.get(position); &#125; @Override public long getItemId(int position) &#123; return position; &#125; @Override public View getView(int position, View convertView, ViewGroup parent) &#123; sharedPreferences=PreferenceManager.getDefaultSharedPreferences(context); Book book=(Book) getItem(position); ViewHolder holder; View view; UpdateAdapter.this.notifyDataSetChanged(); if(convertView==null) &#123; view=LayoutInflater.from(context).inflate(R.layout.book_item,null); holder=new ViewHolder(); holder.book_name=(TextView)view.findViewById(R.id.book_name); holder.author=(TextView)view.findViewById(R.id.author); holder.info=(TextView)view.findViewById(R.id.info); holder.update_title=(TextView)view.findViewById(R.id.update_title); holder.update_time=(TextView)view.findViewById(R.id.update_time); holder.book_img=(ImageView)view.findViewById(R.id.book_img); view.setTag(holder); &#125;else &#123; view=convertView; holder=(ViewHolder) view.getTag(); &#125; if(!sharedPreferences.getBoolean(&quot;no_picture_mode&quot;,true)) &#123; holder.book_img.setVisibility(View.VISIBLE); Picasso.with(context).load(&quot;https:&quot;+book.imgUrl).into(holder.book_img); &#125;else &#123; holder.book_img.setVisibility(View.GONE); &#125; holder.book_name.setText(book.bookName); holder.author.setText(book.author); holder.info.setText(book.info); holder.update_title.setText(book.updateTitle); holder.update_time.setText(book.updateTime); return view; &#125; class ViewHolder &#123; private TextView book_name; private TextView author; private TextView info; private TextView update_title; private TextView update_time; private ImageView book_img; &#125;&#125; 缓存数据缓存数据用的是数据库，主要有两个类DatabaseHelper用于创建个更新数据库，DatabaseUtil类主要是一些操作数据库的函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class DatabaseHelper extends SQLiteOpenHelper &#123; public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); &#125; @Override public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; //添加小说表创建语句 sqLiteDatabase.execSQL(&quot;create table if not exists novel_link(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;url text)&quot;); //小说详情链接表 sqLiteDatabase.execSQL(&quot;create table if not exists novel_info_link(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;url text)&quot;); //小说更新缓存表 sqLiteDatabase.execSQL(&quot;create table if not exists novel_cache(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;author text,&quot; + &quot;updateTitle text,&quot; + &quot;updateTime text)&quot;); &#125; @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123; switch(i) &#123; case 1: sqLiteDatabase.execSQL(&quot;create table if not exists novel_info_link(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;url text)&quot;); sqLiteDatabase.execSQL(&quot;create table if not exists novel_cache(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;author text,&quot; + &quot;updateTitle text,&quot; + &quot;updateTime text)&quot;); case 2: sqLiteDatabase.execSQL(&quot;create table if not exists novel_cache(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;novel_name text,&quot; + &quot;author text,&quot; + &quot;updateTitle text,&quot; + &quot;updateTime text)&quot;); default: &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236/** * Created by dnw on 2017/4/1. */public class DatabaseUtil &#123; public static final String DB_NAME=&quot;novel.db&quot;; public static final int VERSION=1; private SQLiteDatabase db; private static DatabaseUtil databaseUtil; private DatabaseUtil(Context context) &#123; DatabaseHelper dbHelper=new DatabaseHelper(context,DB_NAME,null,VERSION); db=dbHelper.getWritableDatabase(); &#125; public synchronized static DatabaseUtil getInstance(Context context) &#123; if(databaseUtil==null) &#123; databaseUtil=new DatabaseUtil(context); &#125; return databaseUtil; &#125; /** * 添加想要跟踪的小说到数据库 * @param novelName * @param url * @return */ public boolean addLinkToDatabase(String novelName,String url) &#123; ContentValues values=new ContentValues(); values.put(&quot;novel_name&quot;,novelName); values.put(&quot;url&quot;,url); db.insert(&quot;novel_link&quot;,null,values); return true; &#125; /** * 获取到的小说详情链接存储到数据库 * @param novelName * @param url * @return */ public boolean addLinkToNovelInfoLink(String novelName,String url) &#123; ContentValues values=new ContentValues(); values.put(&quot;novel_name&quot;,novelName); values.put(&quot;url&quot;,url); db.insert(&quot;novel_info_link&quot;,null,values); return true; &#125; /** * 缓存到数据库 * @param novelName * @param author * @param update * @param time * @return */ public boolean cacheToNovelCache(String novelName,String author,String update,String time) &#123; ContentValues values=new ContentValues(); values.put(&quot;novel_name&quot;,novelName); values.put(&quot;author&quot;,author); values.put(&quot;updateTitle&quot;,update); values.put(&quot;updateTime&quot;,time); db.insert(&quot;novel_cache&quot;,null,values); return true; &#125; /** * 获取所添加的小说数量 * @return */ public int getNovelLinkCount() &#123; String sql=&quot;select count(*) from novel_link&quot;; Cursor cursor=db.rawQuery(sql,null); cursor.moveToFirst(); int count=(int)cursor.getLong(0); cursor.close(); return count; &#125; /** * 取小说详情链接的数量 * @return */ public int getNovelInfoLinkCount() &#123; String sql=&quot;select count(*) from novel_info_link&quot;; Cursor cursor=db.rawQuery(sql,null); cursor.moveToFirst(); int count=(int)cursor.getLong(0); cursor.close(); return count; &#125; /** * 获取添加的小说list * @return */ public List&lt;Map&lt;String,String&gt;&gt; getNovelLinkElement() &#123; List&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&lt;&gt;(); Map&lt;String,String&gt; map; Cursor cursor=db.query(&quot;novel_link&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; map=new HashMap&lt;&gt;(); String url=cursor.getString(cursor.getColumnIndex(&quot;url&quot;)); String name=cursor.getString(cursor.getColumnIndex(&quot;novel_name&quot;)); map.put(name,url); list.add(map); &#125;while(cursor.moveToNext()); &#125; cursor.close(); return list; &#125; /** * 获取获取的小说详情链接list * @return */ public List&lt;String&gt; getNovelInfoLinkElement() &#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); Cursor cursor=db.query(&quot;novel_info_link&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; String url=cursor.getString(cursor.getColumnIndex(&quot;url&quot;)); list.add(url); &#125;while(cursor.moveToNext()); &#125; cursor.close(); return list; &#125; /** * 获取添加的小说链接 * @return */ public List&lt;String&gt; getNovelNameElement() &#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); Cursor cursor=db.query(&quot;novel_link&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; String url=cursor.getString(cursor.getColumnIndex(&quot;novel_name&quot;)); list.add(url); &#125;while(cursor.moveToNext()); &#125; return list; &#125; public List&lt;CacheBook&gt; getNovelCacheElement() &#123; List&lt;CacheBook&gt; list=new ArrayList&lt;&gt;(); Cursor cursor=db.query(&quot;novel_cache&quot;,null,null,null,null,null,null,null); if(cursor.moveToFirst()) &#123; do &#123; CacheBook book=new CacheBook(); book.cacheBookName=cursor.getString(cursor.getColumnIndex(&quot;novel_name&quot;)); book.cacheAuthor=cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); book.cacheUpdateTitle=cursor.getString(cursor.getColumnIndex(&quot;updateTitle&quot;)); book.cacheUpdateTime=cursor.getString(cursor.getColumnIndex(&quot;updateTime&quot;)); list.add(book); &#125;while(cursor.moveToNext()); &#125; return list; &#125; /** * 删除数据库中添加的小说 * @param novelName * @return */ public boolean delNovelLinkElement(String novelName) &#123; int deleteRow=db.delete(&quot;novel_link&quot;,&quot;novel_name=?&quot;,new String[]&#123;novelName&#125;); if(deleteRow&gt;=0) return true; return false; &#125; /** * 删除cache数据库链接 * @return */ public boolean delAllNovelCacheElement() &#123; db.delete(&quot;novel_cache&quot;,null,null); return true; &#125; public boolean delNovelInfoLinkElement() &#123; db.delete(&quot;novel_info_link&quot;,null,null); return true; &#125; /** * 判断小说是否存在 * @param novelName * @return */ public boolean isExist(String novelName) &#123; Cursor cursor=db.query(&quot;novel_link&quot;,null,&quot;novel_name=?&quot;,new String[]&#123;novelName&#125;,null,null,null); if(cursor.moveToFirst()) &#123; return true; &#125; cursor.close(); return false; &#125; /** * 判断小说链接是否存在 * @param novelName * @return */ public boolean isNovelInfoExist(String novelName) &#123; Cursor cursor=db.query(&quot;novel_info_link&quot;,null,&quot;novel_name=?&quot;,new String[]&#123;novelName&#125;,null,null,null); if(cursor.moveToFirst()) &#123; return true; &#125; cursor.close(); return false; &#125;&#125; 后台更新后台更新主要使用了service以及Android的Alarm机制实现定时任务，以及Notification实现通知,然后使用了BoradReceiver在刷新时间到了的时候重新开启服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * Created by dnw on 2017/4/3. */public class CacheService extends Service &#123; public static final int anHour=60*60*1000; private List&lt;CacheBook&gt; lastList; private DatabaseUtil databaseUtil=DatabaseUtil.getInstance(this); private NotificationManager nm; private int setHour; SharedPreferences sharedPreferences; Handler handler=new Handler() &#123; @Override public void handleMessage(Message msg) &#123; if(msg.what==0x234) &#123; //此处比较两个列表是否相同 List&lt;CacheBook&gt; listDb=databaseUtil.getNovelCacheElement(); //循环比较 if(lastList.size()&gt;0&amp;&amp;listDb.size()&gt;0) &#123; for(int i=0;i&lt;lastList.size();i++) &#123; CacheBook book1=lastList.get(i); for(int j=0;j&lt;listDb.size();j++) &#123; CacheBook book2=listDb.get(j); //书名相同之后比较两书的更新时间，不同发出更新通知 if(book1.cacheBookName.equals(book2.cacheBookName)) &#123; if(!book1.cacheUpdateTime.equals(book2.cacheUpdateTime)) &#123; //此处发出更新通知 Intent intent=new Intent(CacheService.this, MainActivity.class); PendingIntent pi=PendingIntent.getActivity(CacheService.this,0,intent,0); Notification.Builder builder=new Notification.Builder(CacheService.this); builder.setContentTitle(book2.cacheBookName+&quot;&gt;&gt;有更新&quot;); builder.setContentText(book2.cacheUpdateTitle+&quot; &quot;+book2.cacheUpdateTime); builder.setWhen(System.currentTimeMillis()); builder.setSmallIcon(R.drawable.notication_icon); builder.setContentIntent(pi); //获取设置页的是否震动参数 if(sharedPreferences.getBoolean(&quot;vibrator_mode&quot;,false)) &#123; builder.setDefaults(Notification.DEFAULT_VIBRATE); &#125; //获取设置页的呼吸灯是否闪烁参数 if(sharedPreferences.getBoolean(&quot;light_mode&quot;,false)) &#123; builder.setDefaults(Notification.DEFAULT_LIGHTS); &#125; Notification notification=builder.getNotification(); //注意每一条更新都要通知 nm.notify(j,notification); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;; @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); nm=(NotificationManager)getSystemService(NOTIFICATION_SERVICE); sharedPreferences= PreferenceManager.getDefaultSharedPreferences(this); &#125; @Override public boolean onUnbind(Intent intent) &#123; return super.onUnbind(intent); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; if(sharedPreferences==null) sharedPreferences= PreferenceManager.getDefaultSharedPreferences(this); if(nm==null) nm=(NotificationManager)getSystemService(NOTIFICATION_SERVICE); setHour=Integer.parseInt(sharedPreferences.getString(&quot;time_of_refresh&quot;,&quot;1&quot;)); //时间间隔到后执行 new Thread(new Runnable() &#123; @Override public void run() &#123; cacheRefresh(); handler.sendEmptyMessage(0x234); &#125; &#125;).start(); AlarmManager manager=(AlarmManager)getSystemService(ALARM_SERVICE); long triggerAtTime= SystemClock.elapsedRealtime()+setHour*anHour; Intent i=new Intent(this,AlarmReceiver.class); PendingIntent pi=PendingIntent.getBroadcast(this,0,i,0); int currentVersion=Build.VERSION.SDK_INT; if(currentVersion&gt;=19) &#123; manager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); &#125;else &#123; manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); &#125; return super.onStartCommand(intent, flags, startId); &#125; private void cacheRefresh() &#123; //更新之前获取上次更新的数据 lastList=databaseUtil.getNovelCacheElement(); if(databaseUtil.getNovelInfoLinkCount()&gt;0) &#123; if(NetworkState.networkConnected(this)&amp;&amp;(NetworkState.wifiConnected(this)||NetworkState.mobileDataConnected(this))) &#123; List&lt;String&gt;listLink=databaseUtil.getNovelInfoLinkElement(); if(databaseUtil.delAllNovelCacheElement()) for(int i=0;i&lt;listLink.size();i++) &#123; CacheBook book=HtmlParserUtil.getCacheUpdateInfo(listLink.get(i)); if(book!=null) databaseUtil.cacheToNovelCache(book.cacheBookName,book.cacheAuthor,book.cacheUpdateTitle,book.cacheUpdateTime); &#125; &#125; &#125; &#125;&#125; 可以看到在BoradReceiver中只做了一件事，就是重新启动service，这样就可以不断以设置的刷新时间来运行后台服务12345678public class AlarmReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //时间到后再次启动service Intent i=new Intent(context, CacheService.class); context.startService(i); &#125;&#125; 夜间模式日间模式与夜间模式就是给APP定义并应用两套不同颜色的主题由于Support Library在23.2.0的版本中才添加了Theme.AppCompat.DayNight主题，所以依赖的版本必须是高于23.2.0的，并且，这个特性支持的最低SDK版本为14，所以，需要兼容Android 4.0的设备，是不能使用这个特性的，在API Level 14以下的设备会默认使用亮色主题。具体不在阐述，网上有很多实现教程。 版本适配主要有两类： Android 版本配置 屏幕适配 为不同屏幕尺寸和不同可绘制对象提供不同的布局设计 其他恩，未经版权所有方如小说网站许可，有点侵权了。所以，本app只用于学习研究，不用于商业 谢谢您的阅读~~~","tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"}]},{"title":"在Linux新建Git服务器","date":"2017-03-27T08:10:32.000Z","path":"2017/03/27/Create-a-git-server/","text":"这几天导师要求在实验室的服务器上(CentOS)搭建一个Git仓库用于管理实验室项目代码。把这个过程贴上来，方便以后查看。CentOS的安装就不在多说。 安装git1yum install git 创建一个git用户用来运行git服务1useradd -m git 安装Gitosis管理公钥安装命令 1234yum install -y python python-setuptools git-coregit clone https://github.com/res0nat0r/gitosis.gitcd gitosispython setup.py install 软件安装完之后是一些配置。先用服务器生成的ssh公钥初始化gitosis。然后把远程PC的公钥添加进并添加管理权限，即可在远程pc管理项目12ssh-keygen -t rsa(一路回车即可)cp ~/.ssh/id_rsa.pub /tmp/ 用刚才的公钥初始化gitosis12su gitgitosis-init&lt;/tmp/id_rsa.pub 在/home/git文件夹下面会生成gitosis和repositories两个文件夹。repositories即为存放公共库的文件夹。 修改/home/git/repositories/gitosis-admin.git/hooks/post-update权限，使具有执行权限1chmod 775 /home/git/repositories/gitosis-admin.git/hooks/post-update 然后在git桌面上克隆gitosis-admin 然后把PC生成的公钥放到keydir文件夹中，在gitosis.conf中添加管理员权限就可以在PC上远程管理权限和git项目注意：此处公钥的文件名必须改成公钥文件里面最后的用户名，如下图所示的root@cnc217： PC具有权限之后，就可以在自己的电脑上管理git项目和权限，如需新添加开发成员，只需把新成员电脑生成的公钥放到gitosis-admin中keydir，在gitosis.conf中在相应的项目中添加新成员即可。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Android子线程中更新UI的几种方法总结","date":"2017-03-06T03:05:13.000Z","path":"2017/03/06/update-ui-in-subthread/","text":"子线程中更新ui的几种方法 handler消息机制 Handler的post方法 View的post方法 Activity的runOnUiThread()方法 handler消息机制具体原理见另一学习笔记 Handler的post方法先看一下源码123456789101112131415/** * Causes the Runnable r to be added to the message queue. * The runnable will be run on the thread to which this handler is * attached. * * @param r The Runnable that will be executed. * * @return Returns true if the Runnable was successfully placed in to the * message queue. Returns false on failure, usually because the * looper processing the message queue is exiting. */public final boolean post(Runnable r)&#123; return sendMessageDelayed(getPostMessage(r), 0);&#125; 调用了sendMessageDelayed，然后通过getPostMessage(r)把runable转换成了消息12345private static Message getPostMessage(Runnable r) &#123; Message m = Message.obtain(); m.callback = r; return m; &#125; 直接把Runable传送给handler具体实现1234567891011new Thread(new Runnable() &#123; @Override public void run() &#123; handler.post(new Runnable() &#123; @Override public void run() &#123; //在这里进行UI操作 &#125; &#125;); &#125;&#125;).start(); View的post方法源码如下12345public boolean post(Runnable action) &#123; final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) &#123; return attachInfo.mHandler.post(action); &#125; 直接是调用了handler的post Activity的runOnUiThread()方法源码1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125;&#125; 同样是调用了Handler的post 总结子线程中更新UI，最根本的是Handler消息机制，但是代码需要写的有点多，其他的几个方法根本上都是基于Handler消息机制的，所以以后再子线程中更新UI可以有选择的选取最合适的一个。","tags":[]},{"title":"解决Android Studio无法查看源码问题","date":"2016-10-05T17:16:00.000Z","path":"2016/10/06/how-to-see-android-source/","text":"解决Android Studio Ctrl+鼠标左键无法查看底层源码的问题。 如下图所示，在查看消息队列插入消息方法enqueueMessage时，无法查看最底层的实现代码 解决方法 第一步tools-&gt;Android-&gt;SDK manager查看是否下载源码Sources for Android没有安装的话，先安装 第二步Files-&gt;Invalidate Caches And Restart 即可以解决无法查看Android源码的问题","tags":[]}]